<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: wpf | uEN Laboratory]]></title>
  <link href="http://s-ueno.github.io/blog/categories/wpf/atom.xml" rel="self"/>
  <link href="http://s-ueno.github.io/"/>
  <updated>2014-11-28T17:47:05+09:00</updated>
  <id>http://s-ueno.github.io/</id>
  <author>
    <name><![CDATA[uEN]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ダイアログ メッセージのデザイン - WPF Vol 09]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/20/wpf-10/"/>
    <updated>2014-11-20T20:28:15+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/20/wpf-10</id>
    <content type="html"><![CDATA[<p>ストア アプリ風のダイアログ メッセージ を作成しました。<br/>
もちろん、アニメーションします。</p>

<p><img src="http://s-ueno.github.io/images/wpf-10-01.png" alt="wpf-10-01" /></p>

<!-- more -->


<p>これも、いつもの如くまずはグリッド デザインから始まります。</p>

<p><img src="http://s-ueno.github.io/images/wpf-10-02.png" alt="wpf-10-02" /></p>

<p>ちなみに図（と、デザイン）は<a href="http://msdn.microsoft.com/ja-jp/jj984295">ココ</a>です。<br/>
(XPS で配布しなさいよ!!@心の声)</p>

<p>Windows 8.1 UX ガイドライン というのが、どこかにあると思います。</p>

<p>さて、話を戻すとWindowのデフォルトStyle上で、グリッドを比率設定してデザインしました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-10-03.png" alt="wpf-10-03" /></p>

<pre><code>&lt;Grid.RowDefinitions&gt;
    &lt;RowDefinition Height="2*" /&gt;
    &lt;RowDefinition Height="auto" /&gt;
    &lt;RowDefinition Height="2*" /&gt;
&lt;/Grid.RowDefinitions&gt;
</code></pre>

<p>作業手順ですが、今回のように具体的な図を基にする場合は、Excelにイメージを張り付けた後にセルの数を数えて、6個、3個、6個で比率だと 2対1対2 だね、という大雑把に設定しています。</p>

<p>次に、真ん中のメッセージタイトル、メッセージ内容、ボタンを大まかに区切っていきます。</p>

<pre><code>&lt;Grid.ColumnDefinitions&gt;
    &lt;ColumnDefinition Width="*" /&gt;
    &lt;ColumnDefinition Width="3*" /&gt;
    &lt;ColumnDefinition Width="*" /&gt;
&lt;/Grid.ColumnDefinitions&gt;
</code></pre>

<p>あとは、このVisibilityをVisibleにすると同時にアニメーションすれば完成です。
ちなみにこれを呼び出す側はViewModelに用意した拡張メソッドをCallするだけです。</p>

<p><img src="http://s-ueno.github.io/images/wpf-10-04.png" alt="wpf-10-04" /></p>

<p>今回のポイントは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.input.keyboardnavigation.aspx">KeyboardNavigation</a> クラスを利用した各種添付プロパティです。</p>

<p><img src="http://s-ueno.github.io/images/wpf-10-05.png" alt="wpf-10-05" /></p>

<p>メッセージ ダイアログなので、デフォルトでフォーカスがあたるボタンがあります。<br/>
この時にボタン以外にフォーカスが当たると困ります。</p>

<p>MSDNを見ると</p>

<blockquote><p>KeyboardNavigation  クラスは、ナビゲーション キーのいずれかが押されたときに、既定のキーボード フォーカスのナビゲーションを実装します。 ナビゲーション キーとは、Tab、Shift + Tab、Ctrl + Tab、Ctrl + Shift + Tab、上方向、下方向、左方向、および右方向の各キーを指します。</p></blockquote>

<p>とあります。</p>

<p>これらのキーを押してもボタン群だけフォーカスが当たるように添付プロパティを設定しています。</p>

<p>いつものごとく、サンプル成果物はGit管理で。</p>

<p><a href="https://github.com/s-ueno/uENLab">@s-ueno/uENLab</a> on GitHub</p>

<p>次回は画面遷移を考えてみます。</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[カスタムコントロールとおまけでIsolatedStorage - WPF Vol 08]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/20/wpf-09/"/>
    <updated>2014-11-20T02:02:02+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/20/wpf-09</id>
    <content type="html"><![CDATA[<p>カスタム コントロールを作成して TabControlと置き換えてみました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-09-01.png" alt="wpf-09-01" /></p>

<!-- more -->


<p>前回はユーザーコントロールでしたが、今度はカスタムコントロールです。</p>

<p>VisualStudioで新しい項目の追加を選択すると</p>

<p><img src="http://s-ueno.github.io/images/wpf-09-02.png" alt="wpf-09-02" /></p>

<p>ユーザーコントロールとは別にカスタムコントロールが選べます。</p>

<p>ユーザーコントロールでは、Xamlファイル+コードビハインドが追加されました。
カスタムコントロールでは、csファイルがメインで、そのStyleリソースがプロジェクト直下にThemesフォルダとGeneric.xamlという形で追加されます。</p>

<p>TabControlの代わりにListContentカスタムコントロールを作成します。<br/>
追加されたGeneric.xamlはListContent.Xamlに名前を変更しました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-09-03.png" alt="wpf-09-03" /></p>

<p>csファイルの中身は、静的コンストラクタとデフォルトスタイル キーの宣言、長いコメントが付いてきます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-09-04.png" alt="wpf-09-04" /></p>

<p>ベースクラスはControlクラスから<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.selector.aspx">Selector</a> クラスに変更しました。</p>

<p>Controlクラスから複数のアイテムを操作するための一連の機能を実装しているItemsControl、さらにそこに選択するという一連の依存関係プロパティを実装しているSelectorクラスを、今回のベースクラスとして採用しています。</p>

<p>Tabコントロールと同等レベルでよければ、このcsファイルは何も実装しなくても問題ありません。
追加されたリソースディクショナリにXamlでStyleとTemplateを実装していくと、それだけで問題なく動作できます。</p>

<p>ちなみに、これを利用するアプリケーション側は1行、TabControlからListContentに書き換えるだけです。</p>

<p><img src="http://s-ueno.github.io/images/wpf-09-05.png" alt="wpf-09-05" /></p>

<p>あとは、デザインをイメージしてXamlのスタイルを記述していきます。<br/>
今回は上部に各タブのタイトルが並び、それを選択するとメインコンテンツに対象のViewが表示される形です。</p>

<pre><code>    &lt;ui:ViewDataTemplateSelector x:Key="templateSelector" /&gt;
    &lt;Style TargetType="{x:Type local:ListContent}"&gt;
        &lt;Setter Property="Focusable" Value="False" /&gt;
        &lt;Setter Property="FocusVisualStyle" Value="{x:Null}"/&gt;
        &lt;Setter Property="KeyboardNavigation.TabNavigation" Value="Local" /&gt;
        &lt;Setter Property="Template"&gt;
            &lt;Setter.Value&gt;
                &lt;ControlTemplate TargetType="{x:Type local:ListContent}"&gt;
                    &lt;Grid&gt;
                        &lt;Grid.RowDefinitions&gt;
                            &lt;RowDefinition Height="auto" /&gt;
                            &lt;RowDefinition Height="*" /&gt;
                        &lt;/Grid.RowDefinitions&gt;
                        &lt;ListBox x:Name="TitleContent" 
                                 Background="Transparent"
                                 HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                 ItemsSource="{TemplateBinding ItemsSource}"
                                 ItemContainerStyle="{StaticResource ListContentHeaderStyle}"
                                 &gt;
                            &lt;ListBox.ItemsPanel&gt;
                                &lt;ItemsPanelTemplate&gt;
                                    &lt;WrapPanel Orientation="Horizontal"/&gt;
                                &lt;/ItemsPanelTemplate&gt;
                            &lt;/ListBox.ItemsPanel&gt;
                        &lt;/ListBox&gt;
                        &lt;ContentPresenter x:Name="MainContent" Grid.Row="1" 
                                          Content="{TemplateBinding SelectedItem}"
                                          ContentTemplateSelector="{StaticResource templateSelector}" /&gt;
                    &lt;/Grid&gt;
                &lt;/ControlTemplate&gt;
            &lt;/Setter.Value&gt;
        &lt;/Setter&gt;
    &lt;/Style&gt;
</code></pre>

<p>ポイントがいくつかあります。</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.input.keyboardnavigation.tabnavigation.aspx">KeyboardNavigation.TabNavigation</a> 添付プロパティ</li>
<li>ListBox</li>
<li>ContentPresenter</li>
</ul>


<h2><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.input.keyboardnavigation.tabnavigation.aspx">KeyboardNavigation.TabNavigation</a> 添付プロパティ</h2>

<p>WPFはツリー構造なのでTabを押下していくと最初にトップレベルのコンテンツにタブが移動してきます。そこで、この添付プロパティ値をLocal設定すると、Tabで今回作成したListContentにフォーカスが入った際に、次のコンテンツではなく、ListContent内部へTabが移動するようになります。</p>

<h2>ListBox / <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.itemcontainerstyle.aspx">ListBox.ItemContainerStyle</a></h2>

<p>今回は上部にヘッダー用のメニューをデザインしています。
ListContentはベースクラスにItemsControlを持つので、そこにバインドされたコレクションの一覧を持ちます。</p>

<p>その一覧をListBoxのItemsSourceにTemplateBindingで転送しています。
ListBoxなので、各行のスタイルを自由にデザインできます。
このスタイルが、上部のメニューのスタイルになります。そのStyleを決定するのが<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.itemcontainerstyle.aspx">ListBox.ItemContainerStyle</a>プロパティです。</p>

<pre><code>&lt;ListBox.ItemContainerStyle&gt;
    &lt;Style TargetType="{x:Type ListBoxItem}"&gt;
</code></pre>

<p>として直接記述することもできますし、<code>&lt;Style  x:Key="ListContentHeaderStyle" TargetType="{x:Type ListBoxItem}"&gt;</code> として別の箇所に記述したものを利用することもできます。</p>

<p>今回は整理するためにも後述の別箇所に切り出しました。</p>

<p>そのStyleも淡々とデザインします。
アイコンを設定できる枠を用意してもいいし、選択されているときだけ背景色を設定するとかでもいいかもしれません。</p>

<h2>ContentPresenter</h2>

<p>Contentには選択してるアイテムをTemplateBindingで転送しています。<br/>
その実態はバインド ソースである <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.listcollectionview.aspx">ListCollectionView</a> 経由でViewModelコレクションの中の選択されている一つです。</p>

<p>ContentTemplateSelectorプロパティを利用することで、コンテンツをどう表示させるかを選択させています。</p>

<p>この仕組みだけで表示はできるのですが、コンテンツの細かい一つ一つをどう表示するかを作りこむことで、ユーザーに体感してもらうことができます。</p>

<p>今回はメニューの一つ一つが滑らかなアニメーションで表示されるように作りこみました。<br/>
些細なことですが、シンプルでも退屈させず、それがコンテンツであることを認識してもらうことができます。</p>

<p>今回はアニメーションの作りこみのために、ListContent.csファイルにコードを追加しています。
アニメーションは<a href="http://msdn.microsoft.com/ja-jp/library/ms742868.aspx">Storyboard</a> クラス、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.media.animation.animationtimeline.aspx#inheritanceContinued">AnimationTimeline</a> クラスと利用するのですが、滑らかにするためのコツとして<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.media.animation.easingfunctionbase.aspx#inheritanceContinued">イージング関数</a>があります。</p>

<p>機械的な動作ではなく、慣性的なアニメーションで滑らかな印象を与えることができます。</p>

<p>XAMLは技術依存ですが資産としてクラス ライブラリに集めていくと、利用するアプリケーション開発は自動でポリシーのように利用できるようになります。</p>

<p>いくつかの基本的な技術資産を実装した段階で、具体的なアプリケーションの作成を考えています。
その際にはラフでいい加減なユースケース シナリオを用いたお手軽分析しながら作成したいと思います。</p>

<p>代表的な残りは・・・</p>

<ul>
<li>ストアアプリ風メッセージボックス</li>
<li>画面遷移</li>
<li>例外専用ダイアログ</li>
<li>TextBox

<ul>
<li>Modern Style化</li>
<li>IMEの注入</li>
<li>型桁対応</li>
<li>AutoComplete</li>
</ul>
</li>
<li>DataGrid

<ul>
<li>Modern Style化</li>
</ul>
</li>
<li>ToggleButton系</li>
<li>ComboBox</li>
</ul>


<p>などでしょうか。</p>

<h2><a href="http://msdn.microsoft.com/ja-jp/library/system.io.isolatedstorage.aspx">IsolatedStorage</a></h2>

<p>おまけで、紹介します。</p>

<p>MSDNを見てもよくわかりませんが、簡単に言うとアプリケーション毎のセキュアな読書用Streamを与えてくれる機能です。Streamなので、具体的なファイルパスを意識する必要がないのが便利です。</p>

<p>また、実際に永続化してくれているので、アプリケーションの次回起動時にその情報を利用できます。</p>

<p>今回は拡張メソッドで用意しました。</p>

<pre><code>
    public static class BackingStore
    {
        public static void SetBackingStore&lt;T&gt;(this T obj, object value, [CallerMemberName] string key = null) where T : class
        {
            var appStore = IsolatedStorageFile.GetUserStoreForAssembly();
            var directoryPath = typeof(T).FullName;
            if (!appStore.DirectoryExists(directoryPath))
            {
                appStore.CreateDirectory(directoryPath);
            }

            using (var stream = new IsolatedStorageFileStream(Path.Combine(directoryPath, key), FileMode.OpenOrCreate, appStore))
            {
                var formatter = new BinaryFormatter();
                formatter.Serialize(stream, value);
            }
        }
        public static object GetBackingStore&lt;T&gt;(this T obj, [CallerMemberName] string key = null) where T : class
        {
            var appStore = IsolatedStorageFile.GetUserStoreForAssembly();
            var directoryPath = typeof(T).FullName;
            if (!appStore.DirectoryExists(directoryPath))
            {
                appStore.CreateDirectory(directoryPath);
            }

            object result = null;
            try
            {
                using (var stream = new IsolatedStorageFileStream(Path.Combine(directoryPath, key), FileMode.OpenOrCreate, appStore))
                {
                    var formatter = new BinaryFormatter();
                    result = formatter.Deserialize(stream);
                }
            }
            catch (Exception ex)
            {

            }
            return result;
        }

        public static void RemoveBackingStore&lt;T&gt;(this T obj) where T : class
        {
            var appStore = IsolatedStorageFile.GetUserStoreForAssembly();
            appStore.Remove();
        }

    }
</code></pre>

<p>プロパティのバッキングストアのように利用します。</p>

<pre><code>public int MyProperty
{
    get { return (int)this.GetBackingStore(); }
    set { this.SetBackingStore(value); }
}
</code></pre>

<p>ただ FileIOしますし、排他制御もしていないので、マルチスレッドはもちろん頻繁にアクセスするような機能でないことは確かです。</p>

<p>今回はSettingで選択した情報を保存・復元する機能を持ちます。
具体的な永続化の場所はユーザーのAppDataフォルダの中に保存されています。</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ユーザーコントロールに学ぶ様々なコンテンツ - WPF Vol 07]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/17/wpf-08/"/>
    <updated>2014-11-17T19:44:57+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/17/wpf-08</id>
    <content type="html"><![CDATA[<p>設定メニューの作成を通じて、ユーザーコントロールについて紹介します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-08-01.png" alt="wpf-08-01" /></p>

<!-- more -->


<p>WPFは柔軟で StyleやTemplate、添付プロパティで多くは対応できるのですが、場合によっては以下のようなレベルでコントロールを作成する場面も出てきます。</p>

<ul>
<li>ユーザーコントロール</li>
<li>カスタムコントロール</li>
<li>カスタム要素</li>
</ul>


<p><a href="http://msdn.microsoft.com/ja-jp/library/ms745025.aspx">MSDNにも記載</a>があります。</p>

<p>また、これらをクラス ライブラリとして開発する場合と、アプリケーションとして開発する場合で適用するプログラミング デザインパターンも変わってきます。</p>

<p>本シリーズのビューの基本クラスとなるBizViewクラスはUserControl派生です。
その基本機能を実装する上でMVVMパターンで作成しているかといえば、クラスライブラリとしての基本セットなのでそうではありません。</p>

<h2>ユーザーコントロール</h2>

<p>VisualStudioで、新しい項目を追加する場合に選択できます。<br/>
ベースクラスがUserControlクラスになります。</p>

<p>主な目的は、より要件に具体的なビューを提供済みのコンテンツを組み合わせて構築することです。<br/>
たとえば、BizViewクラスから派生したView/ViewModelの各種コンテンツ(サンプルのVol04View/Vol05Viewなど)も同様に、目的とする画面をボタンやラベルといった提供済みコンテンツを配置して作成しています。</p>

<p>それと比べて、カスタムコントロールやカスタム要素は、WPFの組込済みコントロール(Buttonのベースクラスは)がそうであるように、基本となるコンテンツ作成として利用します。</p>

<p>FrameworkElement派生ではパフォーマンスが向上しますが、実装する際には <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.media.drawingvisual.aspx">DrawingVisual</a> クラスなどを利用して、描画を実装する必要が出てきます。</p>

<p>さて、今回は画面の右側に表示する設定画面をユーザーコントロールで作成します。<br/>
画面は以下の構成で、コンテンツ部には指定したView/ViewModelのセットが追加できるよう検討します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-08-03.png" alt="wpf-08-03" /></p>

<p>ユーザーコントロールなので、Xamlで画面を開発する要領で作成します。</p>

<p>Xamlも上から下まで30行程度です。</p>

<ul>
<li>グリッドをデザイン通りに上下分割</li>
<li>上部にタイトルとアイコン</li>
<li>下部に設定タイトル一覧とメインコンテンツ</li>
</ul>


<p>を配置しています。</p>

<pre><code>&lt;UserControl x:Class="uEN.UI.Controls.Settings"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:uen="clr-namespace:uEN.UI"
             mc:Ignorable="d" 
             Background="{DynamicResource AppBrand}"
             Foreground="White"
             BorderBrush="Transparent"
             d:DesignHeight="300" d:DesignWidth="300"&gt;
    &lt;UserControl.Resources&gt;
        &lt;uen:ViewDataTemplateSelector x:Key="templateSelector" /&gt;
    &lt;/UserControl.Resources&gt;
    &lt;Grid&gt;
        &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height="auto"/&gt;
            &lt;RowDefinition Height="*"/&gt;
        &lt;/Grid.RowDefinitions&gt;
        &lt;StackPanel Margin="10,30,0,30" Orientation="Horizontal"&gt;
            &lt;Button x:Name="IconButton" Width="35" Height="35" Margin="5" 
                    Foreground="White"
                    BorderBrush="White"
                    Style="{DynamicResource EllipseButtonStyle}" 
                    &gt;
                &lt;Viewbox Stretch="Fill"&gt;
                    &lt;Path Style="{DynamicResource PathButtonStyle}"
                          Data="F1 M 33.6458,38L 49.4792,53.8333L 38.7917,53.8333L 22.1667,38L 38.7917,22.1667L 49.4792,22.1667L 33.6458,38 Z "/&gt;
                &lt;/Viewbox&gt;
            &lt;/Button&gt;
            &lt;TextBlock x:Name="Caption" Text="Settings" FontSize="20" VerticalAlignment="Center"/&gt;
        &lt;/StackPanel&gt;
        &lt;ListBox Grid.Row="1" x:Name="SettingViewModels" Visibility="Visible" /&gt;
        &lt;ContentPresenter Grid.Row="1" x:Name="ViewModelPresenter"  
                          ContentTemplateSelector="{StaticResource templateSelector}"
                          /&gt;
    &lt;/Grid&gt;
&lt;/UserControl&gt;
</code></pre>

<p>アイコンのジオメトリも前回同様に<a href="http://modernuiicons.com/">Alex Peattie</a>さんのものを利用しています。</p>

<p>ボタンは丸く描画されるように <code>Style="{DynamicResource EllipseButtonStyle}"</code> としてスタイルをリソースとして切り出し、コンテンツにジオメトリを設定しています。</p>

<p>切り出したスタイルは単に  <code>&lt;Setter Property="Template"&gt;</code> としてControlTemplateを設定する際に、Mindwos 8 Styleではフラットで角なしの線を描画するために <code>&lt;Border&gt;</code> としましたが、これを <code>&lt;Ellipse&gt;</code> として丸にすればそれだけでOKです。</p>

<p>ボタンを押したときの内部動作はコードビハインド上で記述しています。<br/>
(クラス ライブラリとしての開発)</p>

<p>アプリケーション構成ファイルに任意のViewModelを設定すると、それが設定画面の一覧に表示されるようにしました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-08-04.png" alt="wpf-08-04" /></p>

<p>あとは、これをWindow Style で定義しているグリッド上にコンテンツとして配置するだけです。</p>

<h2>アニメーション</h2>

<p>ボタンを押下する度に先ほど作成したユーザーコントロールがWindowとしてモーダル表示されたり、画面上にパッとでたり消えたりするのは、利用者としては新鮮さにかけます。
XAMLで作成するアプリケーションのゴールは、やはり柔軟なアニメーションを利用者に体験してもらうことにあります。</p>

<p>今回は、そんなアニメーションを添付プロパティとして切り出して実装しています。</p>

<pre><code>
  public enum TransitionStyle
    {
        None,

        Slide,
        VerticalSlide,

        SlideOut,
        VerticalSlideOut,
    }

    public class ViewTransition
    {
        public static TransitionStyle GetTransitionStyle(DependencyObject obj)
        {
            return (TransitionStyle)obj.GetValue(TransitionStyleProperty);
        }

        public static void SetTransitionStyle(DependencyObject obj, TransitionStyle value)
        {
            obj.SetValue(TransitionStyleProperty, value);
        }

        // Using a DependencyProperty as the backing store for TransitionStyle.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty TransitionStyleProperty =
            DependencyProperty.RegisterAttached("TransitionStyle", typeof(TransitionStyle), typeof(ViewTransition), new UIPropertyMetadata(TransitionStyle.None, OnTransitionStyleChanged));

        private static void OnTransitionStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var fw = d as FrameworkElement;
            var style = e.NewValue as TransitionStyle?;
            if (!style.HasValue || style == TransitionStyle.None)
                return;

            fw.Loaded -= fw_Loaded;
            fw.Loaded += fw_Loaded;
        }

        static void fw_Loaded(object sender, RoutedEventArgs e)
        {
            var fw = (FrameworkElement)sender;
            var style = GetTransitionStyle(fw);

            Play(fw, style);
        }

        public static Storyboard Play(FrameworkElement target, TransitionStyle style, Action completedAction = null)
        {
            Storyboard storyboard = null;
            switch (style)
            {
                case TransitionStyle.None:
                    break;
                case TransitionStyle.Slide:
                    storyboard = CreateSlideStoryboard();
                    break;
                case TransitionStyle.VerticalSlide:
                    storyboard = CreateVerticalSlideStoryboard();
                    break;
                case TransitionStyle.SlideOut:
                    storyboard = CreateSlideStoryboard(false);
                    break;
                case TransitionStyle.VerticalSlideOut:
                    storyboard = CreateVerticalSlideStoryboard(false);
                    break;
                default:
                    break;
            }
            if (completedAction != null)
                storyboard.Completed += (x, y) =&gt; completedAction();
            storyboard.Begin(target);
            return storyboard;
        }

        private static Storyboard CreateSlideStoryboard(bool isFadeIn = true)
        {
            var storyboard = new Storyboard();

            var fromThickness = isFadeIn ? new Thickness(30, 0, -30, 0) : new Thickness(0);
            var toThickness = isFadeIn ? new Thickness(0) : new Thickness(30, 0, -30, 0);

            var slideAnimation = new ThicknessAnimation();
            slideAnimation.From = fromThickness;
            slideAnimation.To = toThickness;
            slideAnimation.Duration = new Duration(TimeSpan.FromSeconds(0.3));

            Storyboard.SetTargetProperty(slideAnimation, new PropertyPath(FrameworkElement.MarginProperty));
            storyboard.Children.Add(slideAnimation);

            var fromOpacity = isFadeIn ? 0 : 1;
            var toOpacity = isFadeIn ? 1 : 0;

            var opacityAnimation = new DoubleAnimation();
            opacityAnimation.From = fromOpacity;
            opacityAnimation.To = toOpacity;
            opacityAnimation.Duration = new Duration(TimeSpan.FromSeconds(0.5));
            Storyboard.SetTargetProperty(opacityAnimation, new PropertyPath(FrameworkElement.OpacityProperty));
            storyboard.Children.Add(opacityAnimation);

            return storyboard;
        }

        private static Storyboard CreateVerticalSlideStoryboard(bool isFadeIn = true)
        {
            var storyboard = new Storyboard();

            var fromThickness = isFadeIn ? new Thickness(0, 30, 0, -30) : new Thickness(0);
            var toThickness = isFadeIn ? new Thickness(0) : new Thickness(0, 30, 0, -30);


            var slideAnimation = new ThicknessAnimation();
            slideAnimation.From = fromThickness;
            slideAnimation.To = toThickness;
            slideAnimation.Duration = new Duration(TimeSpan.FromSeconds(0.3));

            Storyboard.SetTargetProperty(slideAnimation, new PropertyPath(FrameworkElement.MarginProperty));
            storyboard.Children.Add(slideAnimation);

            var fromOpacity = isFadeIn ? 0 : 1;
            var toOpacity = isFadeIn ? 1 : 0;

            var opacityAnimation = new DoubleAnimation();
            opacityAnimation.From = fromOpacity;
            opacityAnimation.To = toOpacity;
            opacityAnimation.Duration = new Duration(TimeSpan.FromSeconds(0.5));
            Storyboard.SetTargetProperty(opacityAnimation, new PropertyPath(FrameworkElement.OpacityProperty));
            storyboard.Children.Add(opacityAnimation);

            return storyboard;
        }

    }
</code></pre>

<p>Xaml上で設定すれば、コンテンツの読み込み時に自動でアニメーションをするようになります。</p>

<p><img src="http://s-ueno.github.io/images/wpf-08-05.png" alt="wpf-08-05" /></p>

<p>また静的メソッドを利用して、任意のタイミングでも動作します。</p>

<h2>まとめ</h2>

<p>ユーザーコントロールで作成したストアアプリスタイルの設定画面を設け、スタイルの変更ができるようになりました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-08-06.png" alt="wpf-08-06" /></p>

<p><img src="http://s-ueno.github.io/images/wpf-08-07.png" alt="wpf-08-07" /></p>

<p>ただし、設定したユーザー固有のスタイルはまだ永続化していません。<br/>
また、TabControlを利用していますが、このコンテンツはどうしても旧来のWindows Formを彷彿させる、モダンではないビシュアルです。</p>

<p>次回の宿題は、ユーザー固有のスタイルは <a href="http://msdn.microsoft.com/ja-jp/library/system.io.isolatedstorage.aspx">IsolatedStorage</a> の機能を利用して永続化したいと思います。
それと、Controlから派生したItemsControlを利用して、モダンなカスタム コントロールを作成したいと思います。</p>

<p>サンプル成果物はGit管理で。</p>

<p><a href="https://github.com/s-ueno/uENLab">@s-ueno/uENLab</a> on GitHub</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windowに学ぶテンプレートと添付プロパティ - WPF Vol 06]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/15/wpf-07/"/>
    <updated>2014-11-15T03:19:00+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/15/wpf-07</id>
    <content type="html"><![CDATA[<p>従来型の開発ではButtonクラスの外観や機能を変更したい場合は、派生させButtonExカスタムコントロールを作成していました。
しかし前回紹介したように、XamlではButtonクラスにスタイルとテンプレートを適用することで、外観をカスタマイズできることを確認しました。</p>

<p>では今度は Window をストアアプリのようなモダンなものに変えたいと思います。
また、スタイルだけではなくそこで発生するイベントも添付プロパティを利用して、外部から制御したいと思います。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-01.png" alt="wpf-07-01" /></p>

<!-- more -->


<p>イメージのWindowは <code>var window = new Window();</code> としているだけで、特にStyleを明示的に設定はしていません。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.application.aspx">System.Windows.Application</a> クラスのリソースに、 <code>&lt;Style TargetType="{x:Type Window}"&gt;</code> と宣言しているリソースディクショナリを登録しているため、デフォルトでこのスタイルで表示されるようになっています。</p>

<p>次に、MSDN で <a href="http://msdn.microsoft.com/ja-jp/library/ms748948.aspx">WPF ウィンドウの概要</a> として紹介している以下の図がわかりやすいのですが</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-02.png" alt="wpf-07-02" /></p>

<p>最小・最大ボタンや境界線などデフォルトで表示されるものをOFFにし、Windowクラスの外観であるクライアント領域内ですべて実装しています。</p>

<p> <code>&lt;Setter Property="Template"&gt;</code> とTemplateを差し替える前までは、お決まりのスタイルである、前景色、背景色、フォントなどをDynamicResource で設定します。</p>

<pre><code>&lt;ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                     xmlns:local="clr-namespace:uEN.UI.AttachedProperties"
                    &gt;
    &lt;Style TargetType="{x:Type Window}"&gt;
        &lt;Setter Property="Foreground"                   Value="{DynamicResource AppForeground}"/&gt;
        &lt;Setter Property="FontFamily"                   Value="{DynamicResource AppFont}"/&gt;
        &lt;Setter Property="FontSize"                     Value="{DynamicResource AppFontSize}"/&gt;
        &lt;Setter Property="Background"                   Value="{DynamicResource WindowTheme}"/&gt;
        &lt;Setter Property="BorderBrush"                  Value="{DynamicResource AppBrand}"/&gt;
        &lt;Setter Property="BorderThickness"              Value="3" /&gt;
        &lt;Setter Property="Focusable"                    Value="False" /&gt;
        &lt;Setter Property="FocusVisualStyle"             Value="{x:Null}"/&gt;
        &lt;Setter Property="WindowStyle"                  Value="None" /&gt;
        &lt;Setter Property="AllowsTransparency"           Value="True" /&gt;
        &lt;Setter Property="ResizeMode"                   Value="CanResizeWithGrip" /&gt;
        &lt;Setter Property="WindowChrome.WindowChrome"&gt;
            &lt;Setter.Value&gt;
                &lt;WindowChrome ResizeBorderThickness="10" /&gt;
            &lt;/Setter.Value&gt;
        &lt;/Setter&gt;
        &lt;Setter Property="Template"&gt;
            &lt;Setter.Value&gt;
                &lt;ControlTemplate TargetType="{x:Type Window}"&gt;
                    &lt;Border BorderBrush="{TemplateBinding BorderBrush}" 
                            BorderThickness="{TemplateBinding BorderThickness}" 
                            Background="{TemplateBinding Background}"&gt;
                        &lt;Grid x:Name="PART_rootGrid"&gt;
                            &lt;Grid.RowDefinitions&gt;
                                &lt;RowDefinition Height="auto"/&gt;
                                &lt;RowDefinition Height="*"/&gt;
                                &lt;RowDefinition Height="auto"/&gt;
                            &lt;/Grid.RowDefinitions&gt;
                            &lt;Grid.ColumnDefinitions&gt;
                                &lt;ColumnDefinition Width="*"/&gt;
                            &lt;/Grid.ColumnDefinitions&gt;
                   ・
                   ・
                   ・
</code></pre>

<p>BorderBrush、BorderThicknessは、<code>&lt;Setter Property="Template"&gt;</code> でこれから差し替えるControlTemplate の最初に</p>

<pre><code>&lt;ControlTemplate TargetType="{x:Type Window}"&gt;
    &lt;Border BorderBrush="{TemplateBinding BorderBrush}" 
            BorderThickness="{TemplateBinding BorderThickness}" 
            Background="{TemplateBinding Background}"&gt;
</code></pre>

<p>としてBorderを用意しTemplateBindingでバインドすることで、画像のように全体の枠線が色付きで表示されるようになっています。</p>

<p>WindowStyleをNone、AllowsTransparencyをTrueとすることで、境界線や最小最大化ボタンの領域が見えなくなります。
ただ、それではWindowを動かせなくなることや、大きさを変更できなくなるので、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.shell.windowchrome.windowchrome.aspx">WindowChrome.WindowChrome</a> 添付プロパティを利用して、Windowの大きさを変更できるための領域幅を指定した新しいWindowChromeを設定しています。</p>

<p>&#8220;`</p>

<!-- WindowChromeは.Net4.5から提供されている機能 -->


<p><Setter Property="WindowChrome.WindowChrome">
    &lt;Setter.Value>
        <WindowChrome ResizeBorderThickness="10" />
    &lt;/Setter.Value>
</Setter>
&#8220;`</p>

<p>これで、リサイズやWibdowの移動ができるようになります。
あとは作成したい画面構成をイメージしながらGridを利用してレイアウトを区切っていきます。</p>

<p>まず、以下のようにしました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-03.png" alt="wpf-07-03" /></p>

<p>Gridを行単位で区切り、上部と下部を可変幅( <code>&lt;RowDefinition Height="auto"/&gt;</code> )、真ん中を領域いっぱいに利用(<code>&lt;RowDefinition Height="*"/&gt;</code>)するように宣言します。</p>

<pre><code> &lt;Grid x:Name="PART_rootGrid"&gt;
     &lt;Grid.RowDefinitions&gt;
         &lt;RowDefinition Height="auto"/&gt;
         &lt;RowDefinition Height="*"/&gt;
         &lt;RowDefinition Height="auto"/&gt;
     &lt;/Grid.RowDefinitions&gt;
     &lt;Grid.ColumnDefinitions&gt;
         &lt;ColumnDefinition Width="*"/&gt;
     &lt;/Grid.ColumnDefinitions&gt;
</code></pre>

<p>こうなると、もう普通のXamlで画面を開発するのと同じように、Style上でControlTemmplateの中身を記述していきます。</p>

<p>まず、Grid上部に対して詳細レイアウトをイメージし、その通りに新しくGridを配置します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-04.png" alt="wpf-07-04" /></p>

<pre><code> &lt;!-- Grid.Row="0"として、親のグリッドの最初の行であることを宣言する --&gt;
 &lt;Grid Grid.Row="0" Height="100"&gt;
     &lt;Grid.RowDefinitions&gt;
         &lt;RowDefinition Height="auto"/&gt;
         &lt;RowDefinition Height="auto"/&gt;
         &lt;RowDefinition Height="*"/&gt;
         &lt;RowDefinition Height="auto"/&gt;
     &lt;/Grid.RowDefinitions&gt;
     &lt;Grid.ColumnDefinitions&gt;
         &lt;ColumnDefinition Width="auto"/&gt;
         &lt;ColumnDefinition Width="auto"/&gt;
         &lt;ColumnDefinition Width="*"/&gt;
         &lt;ColumnDefinition Width="*"/&gt;
     &lt;/Grid.ColumnDefinitions&gt;
</code></pre>

<p>次に0列目、4行をまたがっている領域を利用します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-05.png" alt="wpf-07-05" /></p>

<p>これは日本人にはなじみ深いExcelのセルをマージする要領ですね。
<code>Grid.Column="0" Grid.RowSpan="4"</code>　とすることで、そのようなマージされた領域を利用できます。</p>

<pre><code>&lt;Border Margin="10,0,5,0" Width="10" Grid.Column="0" Grid.RowSpan="4" Background="{DynamicResource AppBrand}" &gt;
    &lt;Border.RenderTransform&gt;
        &lt;TransformGroup&gt;
            &lt;SkewTransform AngleY="50" /&gt;
        &lt;/TransformGroup&gt;
    &lt;/Border.RenderTransform&gt;
&lt;/Border&gt;
</code></pre>

<p>そこにBorder でブランドカラーの四角形を描画しています。
ただ、その四角形はWPFの強力な2Dグラフィック機能を利用して、少し角度をつけて描画しています。</p>

<p>ブランドに注目を集める事、アプリケーションのテーマカラーを確認できることを目的にしています。</p>

<p>次にブランドを表示する箇所です。同じようにグリッドのセルの座標を指定して領域を確保しますが、ここの文字はアプリケーションによって異なります。
そのため、バインドする必要があります。</p>

<p>このシリースはWindow.ContentにViewModelを、ContentTemplateSelectorを利用してViewを表示しています。</p>

<p>なので、このコンテンツにとって、バインドする際のプロパティまでのパスは、Content.(ViewModelのプロパティ名)とし、それを解決するための相対的な位置をバインディングに指定しています。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-06.png" alt="wpf-07-06" /></p>

<p>ViewModelの基底クラスにプロパティを用意することで、デフォルトで適用するもしくは開発者がViewModel側で任意に設定して表示することが可能となります。</p>

<pre><code>public string CompanyName
{
    get { return companyName; }
    set { SetProperty(ref companyName, value); }
}
private string companyName = BizUtils.AppSettings("CompanyName", "");
</code></pre>

<p>後は同じようにデザインしていくのですが、今回は最小最大ボタンと設定ボタンという任意のボタンを配置しました。</p>

<p>最大最小のボタン デザイン面では、描画に<a href="http://www.itmedia.co.jp/help/tips/windows/w0288.html">Marlett</a> フォントを利用しています。
また、×ボタンはフォーカスを受け取ると、赤で強調表示されるようにしています。</p>

<p>設定マークは <a href="http://modernuiicons.com/">Alex Peattie</a>さんのフリーのXamlのジオメトリを利用しています。</p>

<p>ただ、レイアウトを用意するのは良いのですが、ここにクリックされた際の実装が必要になります。
そこで登場するのが、添付プロパティです。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-07.png" alt="wpf-07-07" /></p>

<p><code>local:WindowProxy.Command="Close"</code></p>

<p>WPFの組み込みコントロールクラスとは関係のない、別クラスで宣言した添付プロパティをセットし、処理を注入することができます。</p>

<p>VisualStudioのコードスニペット機能を利用してpropaと入力すると自動で添付プロパティが作成されます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-08.png" alt="wpf-07-08" /></p>

<p><img src="http://s-ueno.github.io/images/wpf-07-09.png" alt="wpf-07-09" /></p>

<p>今回はWindowの最小・最大　+　設定ボタンの押下時の処理を実装する添付プロパティクラスを用意しました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-10.png" alt="wpf-07-10" /></p>

<p>プロパティ値の変更時に処理が動くメソッドが定義できます。
ここで、ボタンに対してクリック時のイベントをバインドしています。</p>

<p>Styleで外観を刷新でき、処理も添付プロパティを利用して注入できるということは、たとえば、開発者はWPFの組込済みテキストボックスを配置、あとは提供されている任意の添付プロパティを選択すれば、自動で数値用テキストボックスや入力自動補完テキストボックスなどに差し替わることが可能となります。</p>

<p>ちなみに、Buttonクラスは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.buttonbase.command.aspx">Button.Command</a>プロパティが用意されていて、ここに組み込み済みのICommandを割り当てることもできます。
たとえば、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.systemcommands.aspx">SystemCommands</a>などです。</p>

<p>そうなのですが・・・・MSもどうしてICoomandをプロパティに持つという条件付の機能にしたのでしょうか？
それこそ添付プロパティとして、任意のルーティングイベントと紐付けられるように提供してくれれば、良かったのですが。</p>

<p>なぜかというと、前回のようにボタンから不要な機能をすべて削り落としていくと</p>

<p><img src="http://s-ueno.github.io/images/wpf-06-08.png" alt="wpf-06-08" /></p>

<p>もうテンプレートの中にはCommandプロパティを持つButtonの要素は存在しないのですよね。。。</p>

<pre><code>    &lt;Style x:Key="ModernButtonStyle" TargetType="{x:Type Button}" &gt;
        &lt;Setter Property="Template"&gt;
            &lt;Setter.Value&gt;
                &lt;ControlTemplate TargetType="Button"&gt;
                    &lt;TextBlock Name="chrome" 
                               HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" 
                               VerticalAlignment="{TemplateBinding VerticalContentAlignment}"&gt;
                        &lt;ContentPresenter /&gt;
                    &lt;/TextBlock&gt;
                    &lt;ControlTemplate.Triggers&gt;
                        &lt;Trigger Property="IsMouseOver" Value="true"&gt;
                            &lt;Setter TargetName="chrome" Property="TextBlock.TextDecorations" Value="Underline" /&gt;
                        &lt;/Trigger&gt;
                    &lt;/ControlTemplate.Triggers&gt;
                &lt;/ControlTemplate&gt;
            &lt;/Setter.Value&gt;
</code></pre>

<p>TextBlockとContentPresenterしか要素がないので、Commandを設定しても動きません。
この制約は、添付プロパティの自由度と比べると見劣りしてしまいます。</p>

<p>ちなみに、今回はまだ設定ボタン押下時の処理を実装していません。
次回は、この設定ボタンを押下すると、アニメーションしながら設定画面が表示されるようにしたいと思います。</p>

<p>サンプル成果物はGit管理で。</p>

<p><a href="https://github.com/s-ueno/uENLab">@s-ueno/uENLab</a> on GitHub</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Buttonに学ぶテンプレートとスタイル - WPF Vol 05]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/11/wpf-06/"/>
    <updated>2014-11-11T23:58:00+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/11/wpf-06</id>
    <content type="html"><![CDATA[<p>Buttonの外観を通じて、テンプレートおよびスタイルについて紹介します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-06-01.png" alt="wpf-06-01" /></p>

<!-- more -->


<h2>Windows 7 スタイル</h2>

<p>WPFがこのお馴染みのスタイルを描画するためには、以下のような要件を適用しています。</p>

<ul>
<li>キーボードフォーカス(入力デバイスがキーボードがミソ。マウスじゃないよ)が入ると、ボタンの枠よりマージン2だけ小さい領域に指定した間隔の点線を描画</li>
<li>論理フォーカスが入ると、ButtonChromeクラスがゴニョゴニョして、ボタンの後ろ側にあるコンテンツの色がアクセント色になる</li>
<li>背景色は上から下に向かい、高さの半分からグラデーションで描画</li>
<li>マウスがボタンの上にくるとボタンの色がアクセント色になる</li>
<li>ボタンの上でマウスが押されている状態時に、ボタンの前景色を濃くする</li>
<li>ボタンの文字は、内部的にContentPresenterに文字を設定しているので、自動でTextBlock化して表示されている</li>
</ul>


<p>などなどキリがありませんが、これらの要件をXAMLのスタイル上で以下のように表現しています。</p>

<p>&#8220;`</p>



<p><LinearGradientBrush x:Key="ButtonNormalBackground" EndPoint="0,1" StartPoint="0,0">
    <GradientStop Color="#F3F3F3" Offset="0"/>
    <GradientStop Color="#EBEBEB" Offset="0.5"/>
    <GradientStop Color="#DDDDDD" Offset="0.5"/>
    <GradientStop Color="#CDCDCD" Offset="1"/>
</LinearGradientBrush>
<SolidColorBrush x:Key="ButtonNormalBorder" Color="#FF707070"/></p>



<pre><code>
このStyleですが、VisualStudio上で以下のように右クリックで簡単に取得できます。

![wpf-06-02]


XAML上に `&lt;Button Width="150" Height="50" Content="送信する" x:Name="SampleButton"/&gt;` と定義するだけで、内部的にはButton用スタイルが自動で適用されているわけです。
ボタン自体のスタイルは `&lt;Style x:Key="AeroButtonStyle" TargetType="{x:Type Button}"&gt;` から始まります。


 `x:Key="AeroButtonStyle"` とキー指定している場合は、XAML上で明示的にキーを設定しないと適用されません。


キー指定せずに `&lt;Style TargetType="{x:Type Button}"&gt;` とStyle定義すると、全てのボタンのスタイルがこれから定義するStyleに自動で従うようになります。  
また、 `&lt;Style TargetType="{x:Type Button}" BasedOn="{StaticResource {x:Type Button}}"&gt;` と、BasedOnを指定することで、元になる定義済みのスタイルを適用した上で任意のスタイルを上書きすることもできます。


 `&lt;Setter Property="FocusVisualStyle" Value="{StaticResource ButtonFocusVisual}"/&gt; `
ですが、TargetTypeが Button で Property名が "FocusVisualStyle" つまり [Button.FocusVisualStyle] プロパティに対して、Value=で "ButtonFocusVisual" というキー名の値を設定していることを表します。


このキー名に一致するものは、以下のようになっています・
</code></pre>



<pre><code>
Margin="2" で StrokeThickness="1" StrokeDashArray="1 2"のRectangleを描画していますね。  
確かにTabでキーボードフォーカスを入れると、ちょっと小さな枠に点線で四角が描画されていませんか？


![wpf-06-03]


WPFが標準で提供する組込みコントロールも、最小限の部品（LabelやTextBlock、Rectangle）を組み合わせて構成されていることがわかります。
なので、これら最小限の部品に対しては、デフォルトでスタイルが適用されるようなことをやってはなりません。

 `&lt;Style TargetType="{x:Type TextBlock}"&gt;` とかすると、TextBlockはいたるところで利用されているので画面がまともに描画されなくなります。

といっても、テキストブロック用のStyleを用意したい場合には `&lt;Style x:Key="MyTextBlock" TargetType="{x:Type TextBlock}"&gt;` のようにキーを明示的に宣言して、他のコントロールに影響がでないようにします。


次に `&lt;Setter Property="` とプロパティ値をカスタマイズしていきますが、この際にスタイルをダイナミックに適用することもできます。

 `&lt;Setter Property="Background" Value="{DynamicResource MyBackgroundBrush}"/&gt; `

[DynamicResource]ですが、これは要素が実際にテンプレートを必要とする（描画）段階で、キー名で検索して適用します。
StaticResourceが定数としたら、DynamicResourceは書き換え可能な変数というところでしょうか。


アプリケーションはそのブランドイメージに見合う色などがあります。
このブログも今は白とブルーを基調としたイメージカラーになっています。
このようなイメージカラーをたとえば、カラーピッカーなどを利用してアプリケーションの実行中にダイナミックに変更することが可能になります。


テンプレート
---


Xamlを利用して、様々なStyleを作成していく中で、 `&lt;Setter Property="Template"&gt; ` については、特別な意味があります。
[Button.Template] プロパティは、このボタンの外観に関する全てを新しく書き換えることを意味します。


Windows7のAeroスタイル例を整理しながら説明します。
</code></pre>

<p><Setter Property="Template">
    &lt;Setter.Value>
        <ControlTemplate TargetType="{x:Type Button}">
            &lt;Themes:ButtonChrome x:Name=&ldquo;Chrome&rdquo; BorderBrush=&ldquo;{TemplateBinding BorderBrush}&rdquo; Background=&ldquo;{TemplateBinding Background}&rdquo; RenderMouseOver=&ldquo;{TemplateBinding IsMouseOver}&rdquo; RenderPressed=&ldquo;{TemplateBinding IsPressed}&rdquo; RenderDefaulted=&ldquo;{TemplateBinding IsDefaulted}&rdquo; SnapsToDevicePixels=&ldquo;true&rdquo;>
                <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/>
            &lt;/Themes:ButtonChrome>
        </ControlTemplate>
    &lt;/Setter.Value>
</Setter>
&#8220;`</p>

<p><code>&lt;ControlTemplate TargetType="{x:Type Button}"&gt;</code> として、Buttonの外観を再定義しています。</p>

<p>その中身は <code>&lt;Themes:ButtonChrome ・・・</code> として、<a href="http://msdn.microsoft.com/ja-jp/library/microsoft.windows.themes.buttonchrome.aspx">Microsoft.Windows.Themes.ButtonChrome</a> クラスを指定しています。
仮にココにCheckBoxを指定した場合は、開発者はButtonをXamlに定義しているにもかかわらず、実行してみると画面上にはチェックボックスが表示されることになります。これがテンプレートです。</p>

<p>各種プロパティに設定している<a href="http://msdn.microsoft.com/ja-jp/library/ms742882.aspx">TemplateBinding</a>は、別のコントロール プロパティ値を参照するバインディング機能になります。
ここでは、ButtonChrome.BorderBrushは、ControlTemplateで定義されているButton(つまりもともとのコントロール)のBorderBrush値を参照するように設定されています。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/ms742882.aspx">TemplateBinding</a> はより具体的で柔軟な設定を可能とし、例えば2個上の親コンテンツのプロパティ値や、指定した親の型が見つかればその値を利用するなど、カスタム コントロールを作成するレベルでは、とても重宝するバインディング機能の一つです。</p>

<p>WPFはバインディングとテンプレートが肝要と紹介する所以です。</p>

<p><code>&lt;ContentPresenter ・・・</code> は Botton.Contentプロパティに設定した&#8221;送信する&#8221;という表示文字列が、ContentPresenterに設定された結果、前に説明した通りTextBlockとして画面に表示されることになります。</p>

<p>WPFのデバック機能で、ビジュアライザーというものがあります。
これを通して、外観を確認すると、なるほどとなります。</p>

<p>サンプルボタン</p>

<p><img src="http://s-ueno.github.io/images/wpf-06-04.png" alt="wpf-06-04" /></p>

<p>そのテンプレートの最終的なContentPresenter</p>

<p><img src="http://s-ueno.github.io/images/wpf-06-05.png" alt="wpf-06-05" /></p>

<p>次に、先ほどは省略しましたが ControlTemplate に、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.controltemplate.triggers.aspx">ControlTemplate.Triggers</a> プロパティ値を設定していたと思います。</p>

<pre><code>&lt;ControlTemplate.Triggers&gt;
    &lt;Trigger Property="IsKeyboardFocused" Value="true"&gt;
        &lt;Setter Property="RenderDefaulted" TargetName="Chrome" Value="true"/&gt;
    &lt;/Trigger&gt;
    &lt;Trigger Property="ToggleButton.IsChecked" Value="true"&gt;
        &lt;Setter Property="RenderPressed" TargetName="Chrome" Value="true"/&gt;
    &lt;/Trigger&gt;
    &lt;Trigger Property="IsEnabled" Value="false"&gt;
        &lt;Setter Property="Foreground" Value="#ADADAD"/&gt;
    &lt;/Trigger&gt;
&lt;/ControlTemplate.Triggers&gt;
</code></pre>

<p>これがXAMLが単なる<a href="http://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E8%A8%98%E8%BF%B0%E8%A8%80%E8%AA%9E">データ記述言語</a>よりも優れていて、なんらかのイベント トリガーをキーに動的にプロパティ値を変更することができる技術になります。</p>

<p>キーボードフォーカスを受け取ったときや、非活性時にはそれに見合ったスタイルを動的に適用することができます。</p>

<p>こういった様々なXAML上の技術が適用されてWindows7のAeroスタイルが適用されていますが、ここで考えたいのが</p>

<blockquote><p>“What is the difference between art and design?”（デザインとアートの違いとは何か？）</p>

<p>”Design solves a problem, art is expression”（デザインとは問題解決であり、アートとは自己表現である。）</p>

<p>Why?をBecauseで説明出来なければ、それは明らかにデザインではない</p></blockquote>

<p>です。</p>

<p>これを素で開発するとした場合は、開発者には高い技術力を求め、OSもこれを描画するための高いコストを支払います。
果たして、これに対して Because を説明できるでしょうか？</p>

<p>そうした結果が、Windows8 Styleや Flat Ftyleにつながりますが、果たしてまだ最適化はできないものでしょうか？</p>

<h2>Windows8 Style</h2>

<p><img src="http://s-ueno.github.io/images/wpf-06-06.png" alt="wpf-06-06" /></p>

<p>Flat Styleはボタンを押下すると、ブランド カラー が表示されています。<br/>
どちらも、無駄なグラデーションなどはなくなりました。</p>

<p>Windows 8 で、同じようにXaml上で右クリック-テンプレートの編集から、適用されているXAMLのスタイルが簡単にコピーできます。</p>

<p>&#8220;`</p>



<pre><code>
Wibndows 7 のAeroスタイルよりもまだ描画コストは減りましたが、あんまり変わりませんね。
もっと、最適化できないか？削れないか？本当にそれは必要か？と考えた際にたどり着くのがModern Styleになります。



Modern Style
---

もはやボタン枠すらもありませんが、確かにユーザーはそれを押下できるコンテンツと認識でき、何が起こるかを理解できます。

![wpf-06-07]


こうなると、XAML上のスタイルも簡単で、OSもこれを描画するためにコストはかけません。  
かといって、ユーザーがこれを退屈なコンテンツと認識するかといえば、とてもモダンな雰囲気を受けます。
</code></pre>



<p>&#8220;`</p>

<p>もはやスタイルは必要最低限で、しかしマウスが乗るとそれが実行可能なコンテンツであることを即座に理解できます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-06-08.png" alt="wpf-06-08" /></p>

<p>ブランドカラーをカスタマイズもできます。
しかも、これはアプリケーション ポリシーのようなもので、開発者はただ単にXaml上でButtonと定義しただけにもかかわらず、自動的にこのスタイルが適用されることになります。</p>

<p>LOB開発が、モダンで先進的なWebデザインに一矢報いることも夢ではありません。</p>

<p>いつものごとく、サンプル成果物はGit管理で。</p>

<p><a href="https://github.com/s-ueno/uENLab">@s-ueno/uENLab</a> on GitHub</p>

<hr />
]]></content>
  </entry>
  
</feed>
