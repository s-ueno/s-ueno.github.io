<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Wpf | uEN Laboratory]]></title>
  <link href="http://s-ueno.github.io/blog/categories/wpf/atom.xml" rel="self"/>
  <link href="http://s-ueno.github.io/"/>
  <updated>2014-11-11T01:10:31+09:00</updated>
  <id>http://s-ueno.github.io/</id>
  <author>
    <name><![CDATA[uEN]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[WPF ViewModelでLOB開発 Vol 04 - コンポジットWPF　おまけでMEF]]></title>
    <link href="http://s-ueno.github.io/blog/2014/10/31/wpf-04/"/>
    <updated>2014-10-31T17:50:00+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/10/31/wpf-04</id>
    <content type="html"><![CDATA[<p>サンプル成果物はGit管理するようにしました。</p>

<p><a href="https://github.com/s-ueno/uENLab">@s-ueno/uENLab</a> on GitHub</p>

<p>今回は、以前からお話ししていましたコンポジットWPFの片鱗と、おまけで <a href="http://msdn.microsoft.com/ja-jp/library/dd460648.aspx">MEF</a> という.Net Frameworkが提供する <a href="http://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E3%81%AE%E6%B3%A8%E5%85%A5">DI</a> について紹介します。</p>

<!-- more -->


<p>コンポジット アプリケーション は動いている画面を見ると1画面なのですが、開発時には複数のコントロールを組み合わせて動くような仕組みになります。
Windows Formの頃はユーザーコントロールとして作成していましたが、ここで利用しているコンテンツ（View/ViewModelセット）には区別はありません。</p>

<p>サンプルを起動すると以下の画面が起動します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-04-01.png" alt="wpf-04-01" /></p>

<p>フレキシブル レイアウトなので、画面を大きくすれば自動でリサイズします。</p>

<p>ShellViewクラスはTabControlを持ち、TabItemとしてアサインしているのものはVol04Viewクラスです。</p>

<p>Vol04Viewクラスには、前回作成した必須入力ルールをテキストボックスに適用しており、ボタン押下のタイミングで検証エラーを検知してアプリケーション例外（業務例外ともいい、致命的な例外とは区別します）をスローします。
ここにMEFの機能を利用して、例外が業務例外ならばその内容を警告メッセージボックスとして表示する仕組みを注入しています。</p>

<ul>
<li>コンポジット構成</li>
<li>MEFによる業務固有処理の抽入</li>
</ul>


<p>それぞれについて紹介します。</p>

<h2>コンポジット構成</h2>

<p>MVVMデザイン パターンでは、どのデータ（ViewModel）をどういう外観で描画する（View）というセットをコンテンツとして取り扱います。</p>

<p>Window が持つ唯一のContentプロパティには、ContentPresenterがあり、コンテンツを表現する箱として機能します。</p>

<p>ContentにViewModelをセットし、このコンテンツの外観を決定するDataTemplateSelectorを利用して、ViewModelの属性として表現したViewを適用しています。</p>

<p>この仕組みはどのようなコンテンツでも適用できます。今回利用した<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.tabcontrol.aspx">TabControl</a>を確認してみます。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.tabcontrol.aspx">TabControl</a>は<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.selector.aspx">Selector</a>,<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.aspx">ItemsControl</a>とベースクラスに持ちます。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.aspx">ItemsControl</a>は複数のコンテンツを持つベースとなるクラスです。<br/>
<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.selector.aspx">Selector</a>は、その複数コンテンツは選択および非選択ができる機能のベースクラスです。<br/>
<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.tabcontrol.aspx">TabControl</a>はそれらの機能を持ち、各コンテンツにセットでHeaderコンテンツを持つクラスになります。</p>

<p>個人的には<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.aspx">ItemsControl</a>、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.selector.aspx">Selector</a>までは優秀なのですが、これを使って作った<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.tabcontrol.aspx">TabControl</a>はちょっと残念な気がしています。
もっと利便性が高い、複数コンテンツを選択可能なコントロールを作成するのはとても簡単なので、シリーズの中で紹介したいと思います。</p>

<p>さておき、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.aspx">ItemsControl</a>などの複数のコンテンツを持つクラスは、大きく二つの機能を利用します。</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.itemssource.aspx">ItemsControl.ItemsSource</a> プロパティ</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.itemtemplateselector.aspx">ItemsControl.ItemTemplateSelector</a> プロパティ</li>
</ul>


<p>ItemsSourceは、その通り複数のデータを設定するプロパティです。
ItemTemplateSelectorは、DataTemplateSelectorと同じで、それぞれのデータはどのような外観なのかを選択するための機能になります。</p>

<p>WindowではContentは一つでしたが、ItemsSourceは複数のコンテンツをセットします。
このセットする際に利便性が高いものが <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.listcollectionview.aspx">ListCollectionView</a> クラスです。</p>

<p>このクラスは外観を持たないコレクションクラスであり、ViewとViewModelに分離したデザインではViewModel側で利用するクラスになります。</p>

<p>ただ、このコレクションにバインドしている外観がもし選択および非選択ができる機能を有するのであれば、そこに指示するMoveCurrentToメソッドなどを持つ、かゆいところに手が届くクラスになります。
このクラスでフィルタリングして10件を2件とした場合なども、外観にも反映され10タブを2タブにしたりすることができます。</p>

<p>ShellView/ShellViewModel クラスはこのコレクションを管理する機能になります。
コンテンツの実体はVol04View/Vol04ViewModelクラスです。</p>

<p>コンポジット アプリケーションではオブジェクト指向を意識しなくても、柔軟なクラス分割を可能とし、それによって同時開発による生産性の向上や保守性の向上、またパフォーマンス向上も期待できます。</p>

<p>業務要件で複雑なTab機能を有する画面を1つのクラスで作成すると、1万STEPを超えるような複雑怪奇なクラスを作りかねないのですが、このような仕組みではどのようなリッチな画面構成でも、シンプルに作成できます。</p>

<h2>MEF</h2>

<p>DIを利用したことがなければピンとこないかもしれません。<br/>
要はインターフェイスに対して、後付けでインスタンスを割り当てることができる機能になります。</p>

<p>LOB開発では様々な横断的関心事が出てきますが、その中には業務要件固有であるものも少なくありません。</p>

<p>業務固有要件なので、システム毎に開発者が用意する機能であり、且つ横断的な関心事であればそれをあちこちでサービス呼び出しするようなことを適用したくない場合に、有効に活用できます。</p>

<p>MEFを利用するためには参照設定で「System.ComponentModel.Composition」を追加する必要があります。</p>

<p>サンプルのSimpleAppプロジェクトにはExceptionPolicyクラスがあります。
このクラスはIExceptionPolicyインターフェイスを実装しています。</p>

<p>このIExceptionPolicyインターフェイスを宣言し、利用しているプロジェクトはuENプロジェクトですが、実際にこのインターフェイスを実装している箇所はありません。
仮にこのインターフェイスに実体が与えられていれば、それを動かすというコーディングのみがあります。</p>

<p>MEFが提供するImport属性を宣言しているので、仮にMEF機能が働けばここにインスタンスがインポートされるイメージになります。
開発者は、このインターフェイスを実装するクラスに対してExport属性を付与することで、そのクラスが適用される仕組みになります。</p>

<p>MEFを利用するにもおまじないコードは必要なのですが、今回はRepositoryクラスを用意しました。</p>

<pre><code>
  public static class Repository
    {
        private static readonly List&lt;ComposablePartCatalog&gt; catalogList = new List&lt;ComposablePartCatalog&gt;();
        static Repository()
        {
            var assemblies = ConfigurationManager.GetSection("Repository.AssemblyCatalog") as NameValueCollection;
            foreach (var each in assemblies.AllKeys)
            {
                var assembly = LoadAssembly(each);
                if (assembly != null)
                {
                    catalogList.Add(new AssemblyCatalog(assembly));
                }
            }

            var types = ConfigurationManager.GetSection("Repository.TypeCatalog") as NameValueCollection;
            foreach (var each in types.AllKeys)
            {
                var type = LoadType(each);
                if (type != null)
                {
                    catalogList.Add(new TypeCatalog(type));
                }
            }

            var catalog = new AggregateCatalog();
            foreach (var each in catalogList)
            {
                catalog.Catalogs.Add(each);
            }
            container = new CompositionContainer(catalog);
        }
        private static Assembly LoadAssembly(string s)
        {
            Assembly assembly = null;
            try
            {
                assembly = Assembly.Load(s);
            }
            catch
            {
            }
            return assembly;
        }
        private static Type LoadType(string s)
        {
            Type type = null;
            try
            {
                type = Type.GetType(s);
            }
            catch
            {
            }
            return type;
        }

        private static CompositionContainer container;
        public static void Compose(this object obj)
        {
            container.ComposeParts(obj);
        }
    }
</code></pre>

<p>このリポジトリが構成ファイルから読み込むべき対象を抽出して実体化可能な状態にセットします。
利用する際には、Import属性を持つクラスのコンストラクタでCompose拡張メソッドを呼び出すことで、そのインターフェイスに自動でインスタンスが割り当てられる仕組みになります。</p>

<p>以下のように利用しています。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class ActionEventPolicyAttribute : Attribute, IRoutedEventPolicy
</span><span class='line'>{
</span><span class='line'>    public ActionEventPolicyAttribute()
</span><span class='line'>    {
</span><span class='line'>        this.Compose();
</span><span class='line'>    }
</span><span class='line'>    [Import(typeof(IExceptionPolicy))]
</span><span class='line'>    public IExceptionPolicy ExceptionPolicy { get; set; }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>アプリケーション構成ファイル(app.config)ですが、configSectionsを利用することで、任意のセクションを追加することが可能になります。
</span><span class='line'>これはmachin.configでも利用されているセクションです。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>ここに二つのレベルで依存性を注入できるようにしています。
</span><span class='line'>
</span><span class='line'> + アセンブリの中にあるExport属性の全てをMEFのカタログに登録する
</span><span class='line'> + アセンブリの中でも特定のクラスのみをMEFのカタログに登録する
</span><span class='line'>
</span><span class='line'>これによって、柔軟で且つソースコードの変更をかけずに機能を差し替えることが可能となります。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>app.config
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?&gt;
</span><span class='line'>&lt;configuration&gt;
</span><span class='line'>  &lt;configSections&gt;
</span><span class='line'>&lt;section name="Repository.AssemblyCatalog" type="System.Configuration.NameValueSectionHandler" /&gt;
</span><span class='line'>&lt;section name="Repository.TypeCatalog" type="System.Configuration.NameValueSectionHandler" /&gt;
</span><span class='line'>  &lt;/configSections&gt;
</span><span class='line'>  &lt;Repository.AssemblyCatalog&gt;
</span><span class='line'>&lt;add key="uEN" value="" /&gt;
</span><span class='line'>&lt;add key="SimpleApp" value="" /&gt;
</span><span class='line'>  &lt;/Repository.AssemblyCatalog&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  &lt;Repository.TypeCatalog&gt;
</span><span class='line'>  &lt;/Repository.TypeCatalog&gt;</span></code></pre></td></tr></table></div></figure></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WPF ViewModelでLOB開発 Vol 03 - バインディング]]></title>
    <link href="http://s-ueno.github.io/blog/2014/10/08/wpf-03/"/>
    <updated>2014-10-08T12:00:00+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/10/08/wpf-03</id>
    <content type="html"><![CDATA[<p>これまでは必要最低限の予備学習でしたが、本質に切り込んで <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.aspx">バインディング</a> について紹介します。<br/>
WPFの肝要は バインディングとテンプレートだと言えるくらい重要です。</p>

<p>今回はDateTimeを表示するだけの簡単なサンプルですが、WPF プロパティ システム の仕組みを覗いてみたいと思います。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-07.png" alt="wpf-03-07" /></p>

<!-- more -->


<p>前回までと同じですが、今度はViewModelのプロパティがDateTime型となっており、バインディング時に一つだけ表示書式が適用されています。</p>

<h2>ViewModel</h2>

<pre><code>    [VisualElements(typeof(BizViewModelName1View))]
    public class BizViewModelName1ViewModel : BizViewModel
    {
        public DateTime? SampleDate
        {
            get { return _sampleDate; }
            set
            {
                SetProperty(ref _sampleDate, value);
            }
        }
        private DateTime? _sampleDate = DateTime.Now;

        public void SampleAction()
        {
            MessageBox.Show(SampleDate.GetValueOrDefault().ToString("yyyy年MM月dd日"));
        }
    }
</code></pre>

<h2>Xaml</h2>

<pre><code>&lt;TextBox Name="SampleTextBox" Text="{Binding Path=SampleDate, StringFormat=yyyy年MM月dd日}"/&gt;
</code></pre>

<p>TextBox.Text プロパティにBindingクラスの指定と、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.path.aspx">Path</a> プロパティおよび<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.bindingbase.stringformat.aspx">StringFormat</a> プロパティを指定しています。
C#で記述するとしてもほぼ同じことを記述します。</p>

<pre><code>BindingOperations.SetBinding(SampleTextBox, TextBox.TextProperty, new Binding("SampleDate") { StringFormat = "yyyy年MM月dd日" });
</code></pre>

<p>WPF プロパティ システムを理解するということは、このBindingクラスの利用方法に他なりません。
どういうことか動かしながら確認したいと思います。</p>

<p>今まで通り、ボタンを押下するとViewModelのプロパティから値を取得してメッセージボックスを表示するアプリケーションです。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-08.png" alt="wpf-03-08" /></p>

<p>テキストボックスにキー入力で日付を変えボタンを押下すると、それがViewModelに自動で反映されている状態です。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-09.png" alt="wpf-03-09" /></p>

<p>現在、Binding クラスにはStringFormat以外何も指定していないにもかかわらず、いくつかの規定の動作が注入されています。<br/>
Binding クラスの機能を全て紹介するのは大変ですが、上記を通じて基本的なものを紹介します。</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> プロパティ</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.updatesourcetrigger.aspx">UpdateSourceTrigger</a> プロパティ</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.validationrules.aspx">ValidationRules</a> プロパティ</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.converter.aspx">Converter</a> プロパティ</li>
</ul>


<h2><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> /  <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.updatesourcetrigger.aspx">UpdateSourceTrigger</a></h2>

<p>まず、現在の動作を確認するとTextBox.Text プロパティにキーボード入力で値を設定し、
ボタンを押下した（テキストボックスからフォーカスが外れた）タイミングでViewModelに画面上のデータが送信されています。</p>

<p>これは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> プロパティと<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.updatesourcetrigger.aspx">UpdateSourceTrigger</a> プロパティが関係しています。</p>

<p>TextBox.Text プロパティにバインディングした場合ですが、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> のデフォルト値は BindingMode.TwoWay となっています。<br/>
テキストボックスなのでキーボード入力が前提で、ViewModelのデータも表示する必要があるため、お互いにデータを双方向でやり取りするモードとなっています。</p>

<p>これがラベルのようにキーボード入力がない場合は、デフォルトのモードは OneWay となります。
多くの提供されているWPFコンテンツは Default で適切ですが、これを変更することができるのが<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> プロパティです。</p>

<p>先ほどの画面で<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> プロパティに OneWay と設定した場合、以下のようにViewModelにはデータが反映されなくなります。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-10.png" alt="wpf-03-10" /></p>

<p>次に、ロストフォーカスでView上のデータがViewModelに自動転送されている設定ですが、MSDNに記述があります。</p>

<blockquote><p>TextBox.Text プロパティの UpdateSourceTrigger の既定値は LostFocus です。</p></blockquote>

<p>WPF プロパティ システム はこれらの設定が既定で適用されている結果、開発者が深く意識しなくても動くアプリケーションが構築できるようになっています。</p>

<p>テキストボックスがロストフォーカス時にViewModelに値を転送するのには理由があります。</p>

<p>TextBox.Text プロパティはキー入力およびIMEでの候補を選択中でも値が変わります。
仮に UpdateSourceTrigger を PropertyChanged に、つまりText プロパティが変わる（≒キータイピング）のたびに
ViewModelへとデータ送信するようになると、想像通りアプリケーションは機能しなくなります。</p>

<h2><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.validationrules.aspx">ValidationRules</a></h2>

<p>ところで、ViewModel上はDateTime型で値を保持しているので、先ほどのテキストボックスで日付に変換できないような値を入力した場合、どうなるでしょう？
試してみます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-11.png" alt="wpf-03-11" /></p>

<p>ボタンを押下するためにフォーカスを外れると&hellip;</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-12.png" alt="wpf-03-12" /></p>

<p>テキストボックスが赤枠表示され、デバックログにはエラーがあった旨が出力されています。</p>

<pre><code>System.Windows.Data Error: 7 : ConvertBack cannot convert value '2014年10月99日' (type 'String'). BindingExpression:Path=SampleDate; DataItem='BizViewModelName1ViewModel' (HashCode=21817343); target element is 'TextBox' (Name='SampleTextBox'); target property is 'Text' (type 'String') FormatException:'System.FormatException: 文字列で表される DateTime がカレンダー System.Globalization.GregorianCalendar でサポートされていません。
   場所 System.DateTime.Parse(String s, IFormatProvider provider)
   場所 System.Convert.ToDateTime(String value, IFormatProvider provider)
   場所 System.Convert.ChangeType(Object value, Type conversionType, IFormatProvider provider)
   場所 System.Windows.Data.BindingExpression.ConvertBackHelper(IValueConverter converter, Object value, Type sourceType, Object parameter, CultureInfo culture)'
</code></pre>

<p>これは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.validationrules.aspx">ValidationRules</a> プロパティに深く関係する、入力値の妥当性検証が規定で実行された結果になります。</p>

<p>この機能は奥深く、大きく三つのことを検討しなければなりません。</p>

<ul>
<li>検証ルールの定義</li>
<li>検証結果の視覚的フィードバック</li>
<li>検証を実行するタイミング</li>
</ul>


<p>これについてもMSDNに丁寧な記載があります。</p>

<blockquote><p>カスタム ErrorTemplate を提供しない場合、検証エラーがあった際にユーザーに視覚的にフィードバックするために、既定のエラー テンプレートが使用されることに注意してください。 詳細については、「データ バインドの概要」の「データの検証」を参照してください。 さらに WPF は、バインド ソース プロパティの更新中にスローされる例外をキャッチするための、組み込みの検証規則を提供します。 詳細については、「ExceptionValidationRule」を参照してください。</p></blockquote>

<p>先ほど学習したように、TextBox.Text プロパティの規定の<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> プロパティは TwoWay つまり双方向通信します。<br/>
さらにそのタイミングを決定する<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.updatesourcetrigger.aspx">UpdateSourceTrigger</a> プロパティは LostFocus のため、フォーカスが外れるタイミングでバインド ソース プロパティ、つまりViewModelのプロパティを更新します。
ただし、2014年10月99日はDateTime型に変換できずエラーが発生した結果、組み込みの検証規則ExceptionValidationRuleが実行、赤枠の規定エラーテンプレートが適用されました。</p>

<ul>
<li>検証ルール

<ul>
<li>バインド ソース プロパティの更新中にスローされる例外をキャッチするための、組み込みの検証規則</li>
</ul>
</li>
<li>結果の外観

<ul>
<li>検証エラーがあった際にユーザーに視覚的にフィードバックするために、既定のエラー テンプレート</li>
</ul>
</li>
<li>検証を実行するタイミング

<ul>
<li>バインド ソース プロパティの更新（ViewのデータをViewModelへ送信しようとするタイミング）</li>
</ul>
</li>
</ul>


<p>これらが全て規定動作で動いた結果、現在の状態になっています。</p>

<p>では、Lob開発をするにあたっては、様々な入力検証（たとえば必須入力や型桁検証）を実行したい状況もあれば、その検証を適用するタイミングもロストフォーカスではなく、任意のタイミングで実行したいなどの要件も発生します。</p>

<p>これらの要件についても、今まで得たバインディングの知識を組み合わせることで、柔軟に対応できます。</p>

<p>UpdateSourceTrigger.Explicit という設定があります。
現在はロストフォーカス時にデータをViewModelへ転送する設定ですが、Explicit では開発者が明示的にデータ転送用のメソッドを呼び出すタイミングでそれが行われます。</p>

<p>では、さっそくコーディングしましょう！</p>

<pre><code>&lt;TextBox Text="{Binding Path=SampleDate, UpdateSourceTrigger=Explicit, StringFormat=yyyy年MM月dd日}" /&gt;
</code></pre>

<p>これだけで、ロストフォーカスでValidationRuleが適用されることはなくなりました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-13.png" alt="wpf-03-13" /></p>

<p>基本ですが、バインディングの肝要です。</p>

<p>ルールを新しく追加することなどもっと簡単で、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.validationrule.aspx">ValidationRule</a> クラスを派生して値を検証するロジックを記述し、それを利用する開発者に提供するだけです。</p>

<p>では、必須入力ルールを作成してみましょう。</p>

<pre><code>    public class RequiredRule : ValidationRule
    {
        public object ErrorContent
        {
            get { return errorContent; }
            set { errorContent = value; }
        }
        private object errorContent = "Required fields.";

        public override ValidationResult Validate(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
                return new ValidationResult(false, ErrorContent);
            if (value is string &amp;&amp; string.IsNullOrEmpty(value as string))
                return new ValidationResult(false, ErrorContent);
            return new ValidationResult(true, null);
        }
    }
</code></pre>

<p>これを Binding.ValidationRules プロパティに Add する作業が必要ですが、それはどうとでもなります。<br/>
気にするとすれば、開発者が簡単かつ柔軟にValidationRule プロパティを拡張して適用できるように気を使うことです。</p>

<p>余談ですが、こういうライブラリを設計するアプローチもいろいろあり、楽しいものです。</p>

<p>『桁や必須かどうかというものは、データの属性である』というアプローチであったり、これを利用する開発イメージを処理と捉えてそこからスタートする方法もあります。</p>

<p>設計するアプローチは様々あり、それを選択していることを受け入れるいうことは重要です。<br/>
与太話でしたが、まとめるとこんなイメージで！</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-14.png" alt="wpf-03-14" /></p>

<p>開発者は、バインドしているデータの書式および必須ルールを属性として利用できるようなイメージです。
このライブラリを開発する際に気にすることがあるとすれば、ルールは開発者が容易に拡張できるようなソリューションだと思います。</p>

<p>ところで、上述の RequiredRule ではデータ単体に着目したのですが、相関的な検証ルールはどうでしょうか。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.validationrule.aspx">ValidationRule</a> クラスをMSDNで確認すると、すでにいくつかの派生クラスが規定で用意されています。</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.exceptionvalidationrule.aspx">ExceptionValidationRule</a> クラス

<ul>
<li>既定で適用されていることを確認しました。</li>
</ul>
</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.dataerrorvalidationrule.aspx">DataErrorValidationRule</a> クラス</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.notifydataerrorvalidationrule.aspx">NotifyDataErrorValidationRule</a> クラス</li>
</ul>


<p>これらは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.validationrules.aspx">ValidationRules</a> プロパティに追加せずとも、自動で有効になるようなオプションが Binding クラスに用意されています。</p>

<pre><code>&lt;TextBox Text="{Binding Path=SampleDate, ValidatesOnDataErrors=True}"/&gt;
&lt;TextBox Text="{Binding Path=SampleDate, ValidatesOnExceptions=True}"/&gt;
&lt;TextBox Text="{Binding Path=SampleDate, ValidatesOnNotifyDataErrors=True}"/&gt;
</code></pre>

<p>多くは規定で適用されており、これらを明示的に意識する必要はありません。</p>

<p>また、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.notifydataerrorvalidationrule.aspx">NotifyDataErrorValidationRule</a> クラスは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.dataerrorvalidationrule.aspx">DataErrorValidationRule</a> クラスの上位機能になります。<br/>
（NotifyDataErrorValidationRule は .Net Framework4.5 で提供されました。）</p>

<p>話を戻すと、この用意されているルールを利用して相関的な検証ロジックを実装する方法について紹介します。</p>

<p>この機能はView（ターゲット）からViewModel（データソース）へと値を転送した後にその値を保持するクラスが
<a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.inotifydataerrorinfo.aspx">INotifyDataErrorInfo</a> インターフェイスを実装していれば、自動で有効になる機能です。</p>

<p>今のサンプルを例にしてみると、 ViewModel の SampleDate プロパティを TextBox.Text プロパティにバインドしています。
TextBoxに値を入力しそれが例外なくSampleDateに転送できた場合に、ViewModelが<a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.inotifydataerrorinfo.aspx">INotifyDataErrorInfo</a> インターフェイスを実装していれば、自動で検証メソッドが実行されます。</p>

<p>この仕組みによって ViewModel上で、複数のプロパティを比較しながら、データの妥当性検証が可能になります。<br/>
これはビジネス エンティティのカプセル化を支援します。</p>

<p>どういうことかといえば、ある業務機能を実装するクラスがあったとします。<br/>
それは Entity Framework を利用したPOCOクラスかもしれないし、型付きDataSetかもしれないし、もしくは業務専用クラスかもしれません。</p>

<p>それらの属性をバインドしているならば、そのクラスが<a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.inotifydataerrorinfo.aspx">INotifyDataErrorInfo</a> インターフェイスを実装することで、そのクラスに閉じた形で検証処理を実装することができます。
このインターフェイスは標準で参照している .Net Framework の System.dll が提供するので、WPFなどのプレゼンテーション テクノロジーとは切り離されています。</p>

<p>MSが提供する <a href="http://www.microsoft.com/ja-jp/dev/2010/solutions/architecture/default.aspx">Application Architecture Guide 2.0</a> では一般的な開発レイヤとして以下の図で説明しています。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-15.png" alt="wpf-03-15" /></p>

<p>ビジネスレイヤーでビジネスエンティティに検証ロジックをカプセル化し、それが自動でプレゼンテーション レイヤで有効化できるようなソリューションです。</p>

<p>ここまでで、単項目の検証ルールおよび複数項目の検証ルールが定義できるようになりました。</p>

<ul>
<li>検証ルールの定義</li>
<li>検証結果の視覚的フィードバック</li>
<li>検証を実行するタイミング</li>
</ul>


<p>あとは『検証結果の視覚的フィードバック』ですが、これはWPFテクノロジーのもう一つの肝要であるテンプレートを紹介する際にしたいと思います。
今は既定の視覚的フィードバックをそのまま利用しましょう。</p>

<h2><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.converter.aspx">Converter</a></h2>

<p>さて、最後に<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.converter.aspx">Converter</a> プロパティについて紹介します。</p>

<p>これは StringFormat プロパティと比べ、よりリッチな変換を適用できます。</p>

<p>例えば、ViewModel上のプロパティ値が列挙体(None,Error,Complete)だった場合に、その列挙体にあったイメージ画像を返すみたいなグル（接着剤）コードをConverterクラスにカプセル化できます。</p>

<p>MSDNのサンプルコードでは</p>

<pre><code>    [ValueConversion(typeof(DateTime), typeof(String))]
    public class DateConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
</code></pre>

<p>という風にIValueConverterインターフェイスの実装と合わせて、ValueConversion属性も付与しています。<br/>
これは自分が作業する分だけなのであれば特に不要なのですが、共通ライブラリなどを作成した際に、それを利用する開発者に対してのメッセージになります。</p>

<p>WPFは自由度が高い反面、ルールがないと意図しない結果になる可能性があります。
たとえばですが、開発者はXaml上でコンボボックスを正しくコーディングしていたとしても、テンプレートというスタイルを書き換える機能が適用された場合は、それがラジオボタンに差し替わって表示されることなど容易に可能です。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.validationrules.aspx">MSDNのこの記事</a>など読むと面白いのですが</p>

<blockquote><p>このベスト プラクティスは、組み込みの WPF コントロール セット用のテーマ コントロール スタイルでの作業の際に、多くの試行錯誤を通じて得られたものです。</p></blockquote>

<p>マイクロソフト内部でもいろいろと苦労したことが伺えます。</p>

<p>例として<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.combobox.aspx">ComboBox</a>クラスを見ると様々な属性を持っていますが、この情報は後に柔軟なスタイルおよびデザイン（機能性）を実現する上でとても重要なものとなります。</p>

<pre><code>[Localizability(LocalizationCategory.ComboBox)]
[TemplatePart(Name = "PART_EditableTextBox", Type = typeof(TextBox))]
[TemplatePart(Name = "PART_Popup", Type = typeof(Popup))]
[StyleTypedProperty(Property = "ItemContainerStyle", StyleTargetType = typeof(ComboBoxItem))]
public class ComboBox : Selector

/*
今はWPFの基本を解決している最中でが、応用してテンプレートを利用する世界では、
技術資産を蓄積できるようになります。

その際にはコンボボックスをカスタマイズしたスタイルの適用や、
添付プロパティによるカスタマイズなどを紹介したいと思います。
*/
</code></pre>

<p>ライブラリとしてIValueConverterを提供する場合は、開発者へのメッセージとしてValueConversion属性をつけてね、ということなのですが・・・</p>

<p>確かに、Xaml上でIValueConverterを適用するためには日付用とか●×用とか何個も専用のクラスを作成する必要があります。</p>

<pre><code>        &lt;StackPanel Grid.Row="0" Grid.Column="1" Orientation="Horizontal" Margin="5" &gt;
            &lt;StackPanel.Resources&gt;
                &lt;local:DateConverter x:Key="dateConverter"/&gt;
            &lt;/StackPanel.Resources&gt;
            &lt;TextBox Name="ConverterTextBox" Text="{Binding Path=SampleDate, Converter={StaticResource dateConverter}, ConverterParameter=arg}"/&gt;
        &lt;/StackPanel&gt;
</code></pre>

<p>ただ、<a href="https://www.google.com/search?q=Expression+Builder%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Expression Builder</a>パターンでコードビハインド上でのコーディングを採用するとしたら、以下で多くは解決できます。</p>

<pre><code>
    public class SimpleConverter : IValueConverter
    {
        public Func&lt;object, Type, object, CultureInfo, object&gt; ConvertMethod { get; set; }
        public Func&lt;object, Type, object, CultureInfo, object&gt; ConvertBackMethod { get; set; }
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (ConvertMethod != null)
                return ConvertMethod(value, targetType, parameter, culture);
            throw new NotImplementedException();
        }
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (ConvertBackMethod != null)
                return ConvertBackMethod(value, targetType, parameter, culture);
            throw new NotImplementedException();
        }
    }
</code></pre>

<p>WPFテクノロジー依存であり、Viewのコードビハインド上に静的メソッドを用意すればかなりシンプルになります。</p>

<p>IValueConverter としてはシステムで共通的なロジックの部品化という視点で拡張すればと思います。
ただ、多くはアドホックで業務（≒画面）固有なので、上記のようなメソッド指定が活躍することは多いです。</p>

<p>以上で、バインディングの基本でありながら、WPFの肝要となる機能の紹介でした。</p>

<p>これらの動作を確認するためのサンプルは<a href="http://s-ueno.github.io/additionalData/uEN-Vol03.zip">コチラ</a></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WPF ViewModelでLOB開発 Vol 02 - ルーティング イベント]]></title>
    <link href="http://s-ueno.github.io/blog/2014/10/01/wpf-02/"/>
    <updated>2014-10-01T14:00:00+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/10/01/wpf-02</id>
    <content type="html"><![CDATA[<p>最初に簡単に<a href="http://msdn.microsoft.com/ja-jp/library/ms247121.aspx">ItemTemplates</a>について紹介して、<a href="http://msdn.microsoft.com/ja-jp/library/ms742806.aspx">ルーティング イベント</a>とビューモデルの紐付おまじないコードの解決を図りたいと思います。</p>

<!-- more -->


<p>たとえばVisualStudio2013をインストールすると、
C:\Users\&ldquo;username&rdquo;\Documents\Visual Studio 2013\Templates\
というフォルダができていると思います。</p>

<p>ここに以下の作業を実施します。</p>

<ul>
<li>【ItemTemplates】フォルダ - 【Visual C#】フォルダの中に新規フォルダ作成（uEN Laboratory）</li>
<li>この<a href="http://s-ueno.github.io/additionalData/BizViewModel.zip">ZIPファイル</a>を先ほどのフォルダに入れる</li>
</ul>


<p>そうすると、クラスの新規追加時に雛形を提供することができます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-02-01.png" alt="wpf-02-01" /></p>

<p>ViewクラスとVeiwModelクラスがセットで追加されます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-02-02.png" alt="wpf-02-02" /></p>

<p>名前空間などはテンプレートがサポートします。</p>

<p><img src="http://s-ueno.github.io/images/wpf-02-03.png" alt="wpf-02-03" />
<img src="http://s-ueno.github.io/images/wpf-02-04.png" alt="wpf-02-04" /></p>

<p>前回はベースクラス名を変えたり、Xamlに名前空間をインポートしたりとかなり手間だったのですが、この機能を利用すると毎回同じ作業を実施しなくて済むようになります。
WPFでの開発生産性を上げる上ではとても有効なので、ぜひ利用してみてください。</p>

<p>カスタマイズするには、さっきのZIPファイルやMSDNを参考にすると簡単にできるのでチェックしてみてください。</p>

<h2>ルーティング イベント</h2>

<p>ボタン押下などのイベント処理を簡単に実装するためには、またおまじないコードが必要になります。<br/>
<a href="http://ja.wikipedia.org/wiki/Model_View_ViewModel">Model-View-ViewModel</a> デザイン パターンを利用しない場合は、Xaml（ザムル）上でダブルクリックすると、Xaml.CSファイルのコードビハインドにクリックイベントが紐付けられます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-02-05.png" alt="wpf-02-05" />
<img src="http://s-ueno.github.io/images/wpf-02-06.png" alt="wpf-02-06" /></p>

<p>ただ、これでは画面をXamlで作成するという難易度だけ上がって、Windows Formとあまり変わりません。
そこで、このイベント処理もバインディングできればと思います。</p>

<p>上記の実装ですが、明示的にRoutedEventを利用してコードビハインド上で記述することもできます。</p>

<pre><code>    SampleButton.AddHandler(Button.ClickEvent, new RoutedEventHandler(SampleButton_Click));
</code></pre>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.buttonbase.clickevent.aspx">Button.ClickEvent</a> は　Buttonクラスに静的に定義され、開発者が利用できるように提供されています。</p>

<p>この仕組みを利用することで、指定したオブジェクトが指定したRoutedEventを実行する際の処理をどこか別の場所（具体的にはViewModel）に定義することができるようになります。</p>

<p><a href="http://ja.wikipedia.org/wiki/Proxy_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Proxyパターン</a>を利用したラッパー経由でViewModelのメソッドに割り付けるようなクラスを準備すれば十分ではないでしょうか。
前回、バインドをタイプセーフに行うためにラムダ式でプロパティ名を指定したように、このイベントの紐付けもラムダ式で行うようにしたいと思います。</p>

<pre><code>    public class RoutedEventBehavior
    {
        public RoutedEvent RoutedEvent { get; set; }
        public object ViewModel { get; set; }
        public DependencyObject Element { get; set; }
        public LambdaExpression LambdaExpression { get; set; }
        protected Action Method { get; set; }
        protected Action&lt;RoutedEventArgs&gt; ArgsMethod { get; set; }
        public virtual void Ensure()
        {
            var uiElement = Element as UIElement;
            if (uiElement == null)
                return;

            if (Method == null &amp;&amp; ArgsMethod == null)
            {
                var compile = LambdaExpression.Compile().DynamicInvoke(ViewModel);
                Method = compile as Action;
                ArgsMethod = compile as Action&lt;RoutedEventArgs&gt;;
            }
            uiElement.AddHandler(RoutedEvent, new RoutedEventHandler(OnEventInternal));
        }
        protected virtual void OnEventInternal(object sender, RoutedEventArgs e)
        {
            var currentCursor = Mouse.OverrideCursor;
            Mouse.OverrideCursor = System.Windows.Input.Cursors.Wait;
            try
            {
                if (Method != null)
                    Method.Invoke();

                if (ArgsMethod != null)
                    ArgsMethod.Invoke(e);
            }
            catch (Exception)
            {
                //エラー時のアプリケーション ポリシー
                throw;
            }
            finally
            {
                Mouse.OverrideCursor = currentCursor;
            }
        }
    }
</code></pre>

<p>サンプル程度の実装ですが、こうすることで、ボタン押下時のマウスカーソルの自動Wait化やエラー時のロギングなどを開発者が実装する必要がなくなります。
ログ出力には、<a href="http://msdn.microsoft.com/ja-jp/library/System.Diagnostics.TraceSource.aspx">TraceSource</a>クラスを利用すると便利なので、別の機会に紹介します。</p>

<p>また、開発者が直接このようなクラスを生成する手間は省きたいです。<br/>
たとえば<a href="https://www.google.com/search?q=Expression+Builder%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Expression Builderパターン</a>なんてプログラミング デザイン パターンを採用してみれば、開発がしやすく可読性があがるかもしれません。</p>

<p>画面上にテキストボックス、ボタンが配置されている場合のコーディング イメージとしてはこのような形でしょうか？</p>

<p><img src="http://s-ueno.github.io/images/wpf-02-07.png" alt="wpf-02-07" /></p>

<p>コントロールを指定して、依存関係プロパティないしルーティング イベントとViewModelのメソッドをタイプセーフに紐付けるビルダーを利用してバインドするという形です。</p>

<p>このコードを記述して実際に動かすとこのようになります。</p>

<p><img src="http://s-ueno.github.io/images/wpf-02-08.png" alt="wpf-02-08" /></p>

<p>テキストボックスに文字を入力し、ボタンをクリックするとViewModel上のSampleActionメソッドが呼び出され、バインドしているSampleTextプロパティから文字を取得してメッセージ表示しています。</p>

<p>ツールレベルならコレでも十分かもしれませんが、実際のLOB開発時には画面に表示する際に変換（<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.ivalueconverter.aspx">IValueConverter</a>）する、入力制限する、他にも様々な作業が発生するので、次回は少しこのバインディングについて掘り下げていきたいと思います。</p>

<p>余談ですが、Buttonクラスは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.buttonbase.command.aspx">Command</a>というプロパティを提供しています。<br/>
こちらを利用することでもボタンのクリックイベント処理を実装することができるのですが、この仕組みはLOBアプリのとあるボタンの押下処理とは意味合いが少し異なることを<a href="http://msdn.microsoft.com/ja-jp/library/ms752308.aspx">目的</a>にしています。</p>

<p>LOBアプリでのイベント処理はルーティング イベントを利用するほうがシンプルです。
コマンドについては別の機会で紹介できればと思います。</p>

<p>今回のサンプルは<a href="http://s-ueno.github.io/additionalData/uEN-Vol02.zip">コチラ</a></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WPF ViewModelでLOB開発 Vol 01 - WPFプロパティ システム]]></title>
    <link href="http://s-ueno.github.io/blog/2014/09/11/wpf-01/"/>
    <updated>2014-09-11T12:03:19+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/09/11/wpf-01</id>
    <content type="html"><![CDATA[<p>LOB開発といえば企業が利用する業務システムで、Windows FormとSQLを利用して、あっという間にデータベースと連係して動くアプリケーションを作成できる技術者は多いと思います。</p>

<p>そんなところに出てきたWPF(Windows Presentation Foundation)。<br/>
とても優れた技術ですが、これをどうLOB開発として利用するかは少し敷居があるのかと感じています。</p>

<p>『WPF ViewModelでLOB開発』シリーズでは、WPFの恩恵を十分に受けつつ、より簡単に開発するための情報を展開します。</p>

<!-- more -->


<h2>WPFテクノロジー</h2>

<p>技術詳細については<a href="http://msdn.microsoft.com/ja-jp">MSDN</a> か <a href="http://blogs.msdn.com/b/shozoa/">荒井省三さんのBlog</a> のWPF編を読むことをお勧めします。<br/>
ここではVisualStudioを利用しながら動かすことに視点を合わせたいと思います。</p>

<h2>ViewModel</h2>

<p>ビューモデルと呼び、この連載タイトルの一部にも登場しています。<br/>
<a href="http://ja.wikipedia.org/wiki/Model_View_ViewModel">Model-View-ViewModel</a> というデザイン パターンの中で、画面の状態を持つオブジェクトです。
Wikiを読むと難しく早くも挫折しそうですが、手を動かしながら確認したいと思います。</p>

<p>Visual Studioを起動して SimpleApp というWPFアプリケーションを作成
<img src="http://s-ueno.github.io/images/wpf-01-01.png" alt="wpf-01-01" />
<img src="http://s-ueno.github.io/images/wpf-01-02.png" alt="wpf-01-02" /></p>

<p>自動でxamlが二つ生成されています。</p>

<ul>
<li>App.xaml

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.application.aspx">System.Windows.Application</a> クラスから派生し、WPFアプリを起動する役目を持ちます。
　</li>
</ul>
</li>
<li>MainWindowo.xaml

<ul>
<li>メイン画面で、Model-View-ViewModel でいうところの View になります。  今回は中央にSampleTextBoxという名前を付けたテキストボックスを配置しました。</li>
</ul>
</li>
</ul>


<pre><code> &lt;TextBox Name="SampleTextBox"/&gt;
</code></pre>

<p>ここに MainWindow の状態を持つための ViewModel を追加します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-03.png" alt="wpf-01-03" />
<img src="http://s-ueno.github.io/images/wpf-01-04.png" alt="wpf-01-04" /></p>

<p>Textという文字列型のプロパティを持ち、コンストラクタで初期化しています。</p>

<pre><code>    class MainWindowViewModel
    {
        public MainWindowViewModel()
        {
            Text = "これはテスト文字列です。";
        }
        public string Text { get; set; }
    }
</code></pre>

<p>次に MainWindow という ビュー が ビューモデル を利用してデータを表示するための設定を行います。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-05.png" alt="wpf-01-05" /></p>

<pre><code>    /// &lt;summary&gt;
    /// MainWindow.xaml の相互作用ロジック
    /// &lt;/summary&gt;
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            this.DataContext = new MainWindowViewModel();

        }
    }
</code></pre>

<p>DataContext というプロパティ名が表すように、ここに設定したオブジェクトがデータを表すということになります。<br/>
これで ViewModel の設定は完了しました。</p>

<p>ここからさらに各コントロール（ここではテキストボックスだけですが）の データ バインディング を行います。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-06.png" alt="wpf-01-06" /></p>

<pre><code>    this.SampleTextBox.SetBinding(TextBox.TextProperty, new Binding("Text"));
</code></pre>

<p>バインディングの方法は様々でXaml(ザムル)といわれる画面を構成するXML上で
<code>&lt;TextBox Name="SampleTextBox" Text="{Binding Path=Text}"/&gt;</code>
と記述することも可能ですが、ここでは意図してコード上でバインディングしています。</p>

<p>TextBox.TextProperty は依存関係プロパティといい、このバインディングの仕組みは<a href="http://msdn.microsoft.com/ja-jp/library/ms752914.aspx">WPF プロパティ システム</a>と呼ばれます。
Bindingクラスのコンストラクタ パラメーターは ViewModel のプロパティ名を設定しています。
この状態でF5キーを押下してデバック実行すると・・・</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-07.png" alt="wpf-01-07" /></p>

<p>表示されましたね！<br/>
フレキシブル レイアウトで、テキストボックスは画面を大きくすると画面と一緒に大きくなります。</p>

<p>画面での入力内容が、DataContext に設定したオブジェクトのプロパティに自動設定されるなどの一連のバインディングの仕組みが用意されており、
この仕組みを利用するのが<a href="http://ja.wikipedia.org/wiki/Model_View_ViewModel">Model-View-ViewModel</a> デザイン パターンです。</p>

<p>注目するのはMainWindowViewModelクラスで、UIから独立した素のクラスです。<br/>
従来の画面とモデルを紐付けるよなグル(接着剤)コードがViewModel上には出てこなくなりました。</p>

<h2>LOB開発基盤　-　ViewModel</h2>

<p>さて、ここまでで発生した「おまじないコード」は・・・</p>

<ul>
<li>WindowのDataContextプロパティへの設定</li>
<li>TextBox.TextPropertyという依存関係プロパティを利用したバインディング作業</li>
</ul>


<p>になります。<br/>
まだまだ記述していないおまじないコードもあり、このままではLOB開発に展開できません。</p>

<p>これらのおまじないコードを基底クラスと一連の機能に隠ぺいすることで、最終的にはViewModelで簡単に画面遷移できるようなソリューションになれれば、WPFの恩恵を受けながらLOB開発を進められるかも？！</p>

<p>基盤はこれからのシリーズで少しずつ機能を固めていくので、まずは準備しましょう。
まずは <a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.inotifypropertychanged.aspx">INotifyPropertyChanged</a> インターフェイスを実装したViewModelのベースクラスを準備します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-08.png" alt="wpf-01-08" /></p>

<pre><code>    public abstract class BizViewModel : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;
        public void OnPropertyChanged(string propertyName = null)
        {
            if (PropertyChanged != null)
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
        }
        protected bool SetProperty&lt;T&gt;(ref T storage, T value, 
            [CallerMemberName] string propertyName = null)
        {
            if (object.Equals(storage, value))
                return false;

            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
</code></pre>

<p>ソースコードは<a href="http://blogs.msdn.com/b/shozoa/">荒井省三さんのBlog</a>で紹介されているものを拝借しました。
ポイントは二つで</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.inotifypropertychanged.aspx">INotifyPropertyChanged</a> インターフェイス</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.runtime.compilerservices.callermembernameattribute.aspx">CallerMemberName</a> 属性</li>
</ul>


<p>になります。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.inotifypropertychanged.aspx">INotifyPropertyChanged</a> インターフェイスは、データ バインディングの仕組みの一つで、何かの処理を実行してViewModelのプロパティに値をセットした場合、それをView側に通知する機能です。
この仕組みで、画面上のデータが再描画されます。<br/>
プロパティのsetで呼び出すようにします。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.runtime.compilerservices.callermembernameattribute.aspx">CallerMemberName</a> 属性は.Net4.5で新しく出てきた機能で、呼び出し元のメンバー名を自動設定してくれる機能です。
少し前までは、プロパティのsetで <code>OnPropertyChanged("●×プロパティ名")</code> みたいにコーディングしていたのですが、その文字を記述する必要がなくなりました。
.Net4.0以前では利用できませんが、必須な属性ではなく、文字列でプロパティ名をコーディングしていた世界から少しだけタイプセーフになりましたというところです。</p>

<p>こういうおまじないコードをViewModelの基底クラスに準備しておくことにします。</p>

<p>次にバインディングの作業です。
先ほどタイプセーフと呼びましたが、なるべくコンパイラのチェックが働くようなコーディングだとソースコードの量が増えたときに便利です。
そこで、バインディングのときにコーディングした</p>

<pre><code>    new Binding("Text")
</code></pre>

<p>ここの&#8221;Text&#8221;というプロパティ名もタイプセーフにセットできるようにしたいと思います。</p>

<p>これはWPFとは関係のない、ただの技術情報なのですが、<a href="http://msdn.microsoft.com/ja-jp/library/bb397687.aspx">ラムダ</a>というコーディングの記述方法があります。<br/>
LINQが利用されるようになってきて、このラムダにおける型の推論によるコーディング方法も浸透してきたと思います。</p>

<pre><code>    //LINQというのは、こんな感じ
    IEnumerable&lt;Customer&gt; customers = customers.Where(c =&gt; c.City == "London");
</code></pre>

<p>C#の経験があるといってもラムダを初めてみる人は、 <code>c =&gt; c.City == "London"</code> の記述を見るとびっくりするかもしれませんが、VisualStudioでインテリセンスが働くので、すぐに慣れると思います。</p>

<p>このラムダを利用して、タイプセーフにViewModelのプロパティ名を取得するような簡単なユーティリティを準備します。
こういうのはすでに世の中に出回っているので、<a href="http://themechanicalbride.blogspot.jp/2007/03/symbols-in-c-30-reloaded.html">探せば出てきます</a>。</p>

<pre><code>    public static class ExpressionExtensions
    {
        public static string ToPropertyName&lt;T&gt;(this T obj, Expression&lt;Func&lt;T, object&gt;&gt; expr)
        {
            return expr.ToSymbol();
        }
        public static string ToSymbol(this Expression expr)
        {
            if (expr == null)
                return null;

            var memExp = (expr as LambdaExpression).Body as MemberExpression;
            var list = new List&lt;string&gt;();
            while (memExp is MemberExpression)
            {
                list.Add(memExp.Member.Name);
                memExp = memExp.Expression as MemberExpression;
            }
            return string.Join(".", list.Reverse&lt;string&gt;());
        }
    }
</code></pre>

<p>あとは MainWindowViewModel のベースクラスを BizViewModel として</p>

<pre><code>    class MainWindowViewModel : BizViewModel
    {
        public MainWindowViewModel()
        {
            Text = "これはテスト文字列です。";
        }
        public string Text
        {
            get { return text; }
            set
            {
                SetProperty(ref text, value);
            }
        }
        private string text; 
    }
</code></pre>

<p>さっきのユーティリティを利用すると</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-09.png" alt="wpf-01-09" /></p>

<pre><code>    /// &lt;summary&gt;
    /// MainWindow.xaml の相互作用ロジック
    /// &lt;/summary&gt;
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            var viewModel = new MainWindowViewModel();
            this.DataContext = viewModel;

            var textPropertyName = viewModel.ToPropertyName(x =&gt; x.Text);
            this.SampleTextBox.SetBinding(TextBox.TextProperty, new Binding(textPropertyName));
        }
    }
</code></pre>

<p>これでコンパイラでチェックがかかるタイプセーフなWPFの簡単な基盤ができました。
イベント系などは次回紹介するとして、今はViewおよびViewModelの役割を設定していきたいと思います。</p>

<h2>LOB開発基盤　-　View</h2>

<p>次にViewについて少し掘り下げていきます。
今はWindowのXamlに直接記述しています。</p>

<pre><code>&lt;Window x:Class="SimpleApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525"&gt;
    &lt;Grid&gt;
        &lt;TextBox Name="SampleTextBox"/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;
</code></pre>

<p>Windowタグの中には一つのコンテンツのみを配置できます。<br/>
今は <code>&lt;Grid&gt;</code> が配置されています。コードで記述すると</p>

<pre><code>    /// &lt;summary&gt;
    /// MainWindow.xaml の相互作用ロジック
    /// &lt;/summary&gt;
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            this.Content = new Grid();
</code></pre>

<p>なので、コンテンツは一つのみとなります。
ただし、このコンテンツがどのように描画されるかはWPFの拡張機能によって変わってきます。</p>

<p>試しにデバック実行し、WPFビジュアライザーで確認してみると</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-10.png" alt="wpf-01-10" /></p>

<p>MainWindowの中にあるContentPresenterにGridが配置されています。<br/>
別の機会に詳しく紹介しますが、WPFの<a href="http://msdn.microsoft.com/ja-jp/library/ms745683.aspx">Style</a>が適用されている結果このような表示になります。</p>

<p>少し前までAero.NormalColor.xamlなどスタイルがMSDNからダウンロードできたのですが、リンクが見つかりませんでした。
現在のデバック実行した環境でWindowクラスに適用されているスタイルは、以下のようになっているのだと思います。</p>

<pre><code>    &lt;Style x:Key="{x:Type Window}"
           TargetType="{x:Type Window}"&gt;
        &lt;Setter Property="Foreground"
                Value="{DynamicResource {x:Static SystemColors.WindowTextBrushKey}}"/&gt;
        &lt;Setter Property="Background"
                Value="{DynamicResource {x:Static SystemColors.WindowBrushKey}}"/&gt;
        &lt;Setter Property="Template"&gt;
            &lt;Setter.Value&gt;
                &lt;ControlTemplate TargetType="{x:Type Window}"&gt;
                    &lt;Border Background="{TemplateBinding Background}"
                            BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"&gt;
                        &lt;AdornerDecorator&gt;
                            &lt;ContentPresenter/&gt;
                        &lt;/AdornerDecorator&gt;
                    &lt;/Border&gt;
                &lt;/ControlTemplate&gt;
            &lt;/Setter.Value&gt;
        &lt;/Setter&gt;
</code></pre>

<p>TemplateというWPFの外観をカスタマイズできる機能があり、ここにコンテンツを表示する際はBorderを用意して、AdornerDecoratorを用意してその中にContentPresenterを・・・という風に定義されています。</p>

<p>話を戻すと、Windowに表示されるコンテンツは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.contentpresenter.aspx">ContentPresenter</a>を利用して表示されるようになっています。</p>

<p>MSDNの<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.contentpresenter.aspx">ContentPresenter</a>をみると、コンテンツがどのようなロジックで表示するかの記述があります。
たとえば、コンテンツに文字列を設定するとTextBlockが自動で作成されて、表示されるようになります。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-11.png" alt="wpf-01-11" /></p>

<p><img src="http://s-ueno.github.io/images/wpf-01-12.png" alt="wpf-01-12" /></p>

<p>F5キーでデバック実行</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-13.png" alt="wpf-01-13" /></p>

<p>任意のクラスの場合はToStringの結果が表示されるのですが、その場合に何を表示すべきかをカスタマイズする機能があります。</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.contentcontrol.contenttemplateselector.aspx">ContentControl.ContentTemplateSelector</a> プロパティ</li>
</ul>


<p>試しにContentTemplateSelectorプロパティに設定して動作確認してみましょう。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-14.png" alt="wpf-01-14" /></p>

<p>戻り値の<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.datatemplate.aspx">DataTemplate</a>はビジュアル要素（つまりView）をあらわし、引数のitemは任意のデータをあらわします。<br/>
この仕組みの面白いところは、<strong>データがビジュアル要素を決定する</strong>というところです。
つまり、ビジュアル要素はデータの属性として表現すると、仕組みを上手に利用できそうだとわかります。</p>

<p>さっそくオブジェクトとしてそれを表現してみたいと思います。<br/>
ビジュアル要素はデータの属性として扱うので</p>

<pre><code>    public class VisualElementsAttribute : Attribute
    {
        public VisualElementsAttribute(Type visualType)
        {
            VisualType = visualType;
        }
        public Type VisualType { get; private set; }
    }
</code></pre>

<p>この属性はデータ（BizViewModelから派生した任意のViewModel）に付与することになります。<br/>
次にビジュアル要素（ビュー）用の基底クラスを用意します。</p>

<pre><code>    public abstract class BizView : UserControl
    {
        protected BizView()
        {
            DataContextChanged += OnBizViewDataContextChanged;
        }
        private void OnBizViewDataContextChanged(object sender, System.Windows.DependencyPropertyChangedEventArgs e)
        {
            BuildBinding();
        }
        protected virtual void BuildBinding()
        {

        }
    }
</code></pre>

<p>上記二つを利用して、BizViewModelに肉付けします。</p>

<pre><code>    public abstract class BizViewModel : INotifyPropertyChanged
    {
        protected BizViewModel()
        {
            if (VisualElements != null)
            {
                View = Activator.CreateInstance(VisualElements.VisualType) as BizView;
            }
        }
        private VisualElementsAttribute visualElements;
        public VisualElementsAttribute VisualElements
        {
            get
            {
                if (visualElements == null)
                {
                    visualElements = this.GetType()
                                         .GetCustomAttributes(typeof(VisualElementsAttribute), false)
                                         .FirstOrDefault() as VisualElementsAttribute;
                }
                return visualElements;
            }
        }
        private BizView view;
        public BizView View
        {
            get { return view; }
            set
            {
                view = value;
                view.DataContext = this;
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;
        public void OnPropertyChanged(string propertyName = null)
        {
            if (PropertyChanged != null)
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
        }
        protected bool SetProperty&lt;T&gt;(ref T storage, T value,
            [CallerMemberName] string propertyName = null)
        {
            if (object.Equals(storage, value))
                return false;

            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
</code></pre>

<p>先ほどDataTemplateSelectorを派生した動作確認用のサンプルを作成しましたが、正しくビジュアル要素を返すDataTemplateSelectorを作成します。</p>

<pre><code>    public class ViewDataTemplateSelector : DataTemplateSelector
    {
        public override DataTemplate SelectTemplate(object item, DependencyObject container)
        {
            var vm = item as BizViewModel;
            if (vm == null || vm.VisualElements == null)
                return base.SelectTemplate(item, container);

            var template = new DataTemplate() { VisualTree = new FrameworkElementFactory(vm.VisualElements.VisualType) };
            template.Seal();
            return template;
        }
    }
</code></pre>

<p>ここまででのLOB開発用の基盤は以下のようになっています。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-15.png" alt="wpf-01-15" /></p>

<p>これを早速使って画面を表示したいと思います。</p>

<h2>LOB開発基盤　-　はじめの一歩</h2>

<p>コンテンツもViewModelも何もない空のMainWindowのみの状態です。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-16.png" alt="wpf-01-16" /></p>

<p>ここにViewを追加します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-17.png" alt="wpf-01-17" /></p>

<p>名前はMainViewで、WPFのユーザーコントロールで追加します。<br/>
VisualStudioにはItemTemplatesフォルダがあって、これを利用すると便利なのですが、それは次回に紹介します。</p>

<p>MainViewクラスのベースクラスをBizViewに変更します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-18.png" alt="wpf-01-18" /></p>

<p>この作業に今は手間がかかりますが、ItemTemplateを紹介するまでの我慢です。</p>

<p>MainView.xamlに先ほど作成した基盤の名前空間をインポート<code>xmlns:uen="clr-namespace:uEN.UI;assembly=uEN"</code>して、メインのタグを<code>&lt;uen:BizView</code>に変更します。<br/>
合わせてMainView.xaml.csのベースクラスも<code>BizView</code>に変更します。</p>

<p>このViewに先ほどと同じようにテキストボックスを配置します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-19.png" alt="wpf-01-19" /></p>

<p>次にMainViewModelを追加します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-20.png" alt="wpf-01-20" /></p>

<pre><code>    [VisualElements(typeof(MainView))]
    public class MainViewModel : BizViewModel
    {
        public MainViewModel()
        {
            MyProperty = "ViewModelでLob開発";
        }
        public string MyProperty { get; set; }
    }
</code></pre>

<p>このViewModelをMainViewのBuildBindingでデータバインディングします。</p>

<pre><code>    /// &lt;summary&gt;
    /// MainView.xaml の相互作用ロジック
    /// &lt;/summary&gt;
    public partial class MainView : BizView
    {
        public MainView()
        {
            InitializeComponent();
        }

        protected override void BuildBinding()
        {
            var viewModel = this.DataContext as MainViewModel;
            var propertyName = viewModel.ToPropertyName(x =&gt; x.MyProperty);
            this.SampleTextBox.SetBinding(TextBox.TextProperty, new Binding(propertyName));
        }
    }
</code></pre>

<p>今は空のMainWindowとMainView/MainViewModelがある状態です。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-21.png" alt="wpf-01-21" /></p>

<p>最後にMainWindowにコンテンツとセレクターを設定します。</p>

<pre><code>    /// &lt;summary&gt;
    /// MainWindow.xaml の相互作用ロジック
    /// &lt;/summary&gt;
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            this.Content = new MainViewModel();
            this.ContentTemplateSelector = new ViewDataTemplateSelector();
        }
    }
</code></pre>

<p>以上で準備が完了です。<br/>
デバック実行すると・・・</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-22.png" alt="wpf-01-22" /></p>

<p>期待した結果が表示されました！</p>

<p>WPFの「おまじないコード」などを基盤に入れていくと、それを利用するLOB開発は楽になると思います。<br/>
たとえば</p>

<ul>
<li>BizViewModelにShowメソッドを用意し、WindowをNewするコードを入れれば・・・</li>
<li>コマンドのバインディングのラッパーを・・・</li>
<li>ロギングが・・・</li>
</ul>


<p>思いつくままをオレオレ実装してもいいですし、<a href="http://www.microsoft.com/ja-jp/dev/2010/solutions/architecture/default.aspx">Application Architecture Guide</a>などを読み解いて、しかるべき処理を準備していくのも一つかもしれません。</p>

<p>次回は今までの作業で手間だったものの自動化を考えてItemTemplatesの紹介と、もう少し踏み込んでボタンを押して動くところまでもっていければと思います。</p>

<p>今回のサンプルは<a href="http://s-ueno.github.io/images/uEN-Vol01.zip">コチラ</a></p>

<hr />
]]></content>
  </entry>
  
</feed>
