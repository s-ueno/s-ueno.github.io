<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[uEN Laboratory]]></title>
  <link href="http://s-ueno.github.io/atom.xml" rel="self"/>
  <link href="http://s-ueno.github.io/"/>
  <updated>2014-12-02T22:17:12+09:00</updated>
  <id>http://s-ueno.github.io/</id>
  <author>
    <name><![CDATA[uEN]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Modern Style TextBox]]></title>
    <link href="http://s-ueno.github.io/blog/2014/12/02/wpf-14/"/>
    <updated>2014-12-02T22:10:27+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/12/02/wpf-14</id>
    <content type="html"><![CDATA[<p>TextBox の Style を Modern Style 対応します。</p>

<!-- more -->


<p>まずは土台を取得したいので、VisualStudio のデザイナ上で TextBox を右クリック
 ⇒ テンプレートの編集 ⇒ コピーして編集で生成されるテンプレートを利用したいと思います。</p>

<p><img src="http://s-ueno.github.io/images/wpf-14-01.png" alt="wpf-14-01" /></p>

<p>ちなみに、現在適用されているデフォルトのテーマで出力されるので、Windows 7 と 8 では違った値がでると思います。
で、8で出力されたのがコレ</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    &lt;SolidColorBrush x:Key="TextBox.Static.Border" Color="#FFABAdB3"/&gt;
</span><span class='line'>    &lt;SolidColorBrush x:Key="TextBox.MouseOver.Border" Color="#FF7EB4EA"/&gt;
</span><span class='line'>    &lt;SolidColorBrush x:Key="TextBox.Focus.Border" Color="#FF569DE5"/&gt;
</span><span class='line'>    &lt;Style x:Key="TextBoxStyle1" TargetType="{x:Type TextBox}"&gt;
</span><span class='line'>        &lt;Setter Property="Background" Value="{DynamicResource {x:Static SystemColors.WindowBrushKey}}"/&gt;
</span><span class='line'>        &lt;Setter Property="BorderBrush" Value="{StaticResource TextBox.Static.Border}"/&gt;
</span><span class='line'>        &lt;Setter Property="Foreground" Value="{DynamicResource {x:Static SystemColors.ControlTextBrushKey}}"/&gt;
</span><span class='line'>        &lt;Setter Property="BorderThickness" Value="1"/&gt;
</span><span class='line'>        &lt;Setter Property="KeyboardNavigation.TabNavigation" Value="None"/&gt;
</span><span class='line'>        &lt;Setter Property="HorizontalContentAlignment" Value="Left"/&gt;
</span><span class='line'>        &lt;Setter Property="FocusVisualStyle" Value="{x:Null}"/&gt;
</span><span class='line'>        &lt;Setter Property="AllowDrop" Value="true"/&gt;
</span><span class='line'>        &lt;Setter Property="ScrollViewer.PanningMode" Value="VerticalFirst"/&gt;
</span><span class='line'>        &lt;Setter Property="Stylus.IsFlicksEnabled" Value="False"/&gt;
</span><span class='line'>        &lt;Setter Property="Template"&gt;
</span><span class='line'>            &lt;Setter.Value&gt;
</span><span class='line'>                &lt;ControlTemplate TargetType="{x:Type TextBox}"&gt;
</span><span class='line'>                    &lt;Border x:Name="border" BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="{TemplateBinding BorderThickness}" Background="{TemplateBinding Background}" SnapsToDevicePixels="True"&gt;
</span><span class='line'>                        &lt;ScrollViewer x:Name="PART_ContentHost" Focusable="false" HorizontalScrollBarVisibility="Hidden" VerticalScrollBarVisibility="Hidden"/&gt;
</span><span class='line'>                    &lt;/Border&gt;
</span><span class='line'>                    &lt;ControlTemplate.Triggers&gt;
</span><span class='line'>                        &lt;Trigger Property="IsEnabled" Value="false"&gt;
</span><span class='line'>                            &lt;Setter Property="Opacity" TargetName="border" Value="0.56"/&gt;
</span><span class='line'>                        &lt;/Trigger&gt;
</span><span class='line'>                        &lt;Trigger Property="IsMouseOver" Value="true"&gt;
</span><span class='line'>                            &lt;Setter Property="BorderBrush" TargetName="border" Value="{StaticResource TextBox.MouseOver.Border}"/&gt;
</span><span class='line'>                        &lt;/Trigger&gt;
</span><span class='line'>                        &lt;Trigger Property="IsKeyboardFocused" Value="true"&gt;
</span><span class='line'>                            &lt;Setter Property="BorderBrush" TargetName="border" Value="{StaticResource TextBox.Focus.Border}"/&gt;
</span><span class='line'>                        &lt;/Trigger&gt;
</span><span class='line'>                    &lt;/ControlTemplate.Triggers&gt;
</span><span class='line'>                &lt;/ControlTemplate&gt;
</span><span class='line'>            &lt;/Setter.Value&gt;
</span><span class='line'>        &lt;/Setter&gt;
</span><span class='line'>        &lt;Style.Triggers&gt;
</span><span class='line'>            &lt;MultiTrigger&gt;
</span><span class='line'>                &lt;MultiTrigger.Conditions&gt;
</span><span class='line'>                    &lt;Condition Property="IsInactiveSelectionHighlightEnabled" Value="true"/&gt;
</span><span class='line'>                    &lt;Condition Property="IsSelectionActive" Value="false"/&gt;
</span><span class='line'>                &lt;/MultiTrigger.Conditions&gt;
</span><span class='line'>                &lt;Setter Property="SelectionBrush" Value="{DynamicResource {x:Static SystemColors.InactiveSelectionHighlightBrushKey}}"/&gt;
</span><span class='line'>            &lt;/MultiTrigger&gt;
</span><span class='line'>        &lt;/Style.Triggers&gt;
</span><span class='line'>    &lt;/Style&gt;</span></code></pre></td></tr></table></div></figure>


<p>VS2013 Update 4 ですが、自動生成した MultiTrigger の Condition の設定値が実は逆というバグは愛嬌ということで(ニコッ)</p>

<p>まず、シンプルなのが一目でわかります。<br/>
Triggerも非活性時には不透明度を設定することでそれっぽく見せるなど、小粋です。
リソースのキーが <code>x:Key="TextBox.MouseOver.Border"</code> とか <code>x:Key="TextBox.Focus.Border"</code> など、.で区切るところが
個人的にとても気に入りました。</p>

<p>ちなみに、ほとんど変える箇所はなく、現在 Background や Foreground が静的参照なので、これを
アプリケーションで統一的なキーに DynamicResource で置き換えるだけです。</p>

<p>WPFの組み込みコントロールで、特にLOB開発に利用するコントロールなどは限られているので、
こんな感じで、技術資産をためていくと、後の開発で楽にガバナンスを効かせられます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-14-02.png" alt="wpf-14-02" /></p>

<p>で、作成したのがコレ。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>    &lt;Style TargetType="{x:Type TextBox}"&gt;
</span><span class='line'>        &lt;Setter Property="Background"       Value="{DynamicResource TextBox.Background}"/&gt;
</span><span class='line'>        &lt;Setter Property="BorderBrush"      Value="{DynamicResource TextBox.BorderBrush}"/&gt;
</span><span class='line'>        &lt;Setter Property="Foreground"       Value="{DynamicResource AppForeground}"/&gt;
</span><span class='line'>        &lt;Setter Property="BorderThickness"  Value="1"/&gt;
</span><span class='line'>
</span><span class='line'>        &lt;Setter Property="KeyboardNavigation.TabNavigation" Value="None"/&gt;
</span><span class='line'>        &lt;Setter Property="HorizontalContentAlignment"       Value="Left"/&gt;
</span><span class='line'>        &lt;Setter Property="FocusVisualStyle"                 Value="{x:Null}"/&gt;
</span><span class='line'>        &lt;Setter Property="AllowDrop"                        Value="true"/&gt;
</span><span class='line'>        &lt;Setter Property="ScrollViewer.PanningMode"         Value="VerticalFirst"/&gt;
</span><span class='line'>        &lt;Setter Property="Stylus.IsFlicksEnabled"           Value="False"/&gt;
</span><span class='line'>        &lt;Setter Property="Template"&gt;
</span><span class='line'>            &lt;Setter.Value&gt;
</span><span class='line'>                &lt;ControlTemplate TargetType="{x:Type TextBox}"&gt;
</span><span class='line'>                    &lt;Border x:Name="border" BorderBrush="{TemplateBinding BorderBrush}" 
</span><span class='line'>                            BorderThickness="{TemplateBinding BorderThickness}" Background="{TemplateBinding Background}" SnapsToDevicePixels="True"&gt;
</span><span class='line'>                        &lt;ScrollViewer x:Name="PART_ContentHost" Focusable="false" 
</span><span class='line'>                                      HorizontalScrollBarVisibility="Hidden" 
</span><span class='line'>                                      VerticalScrollBarVisibility="Hidden"/&gt;
</span><span class='line'>                    &lt;/Border&gt;
</span><span class='line'>                    &lt;ControlTemplate.Triggers&gt;
</span><span class='line'>                        &lt;Trigger Property="IsEnabled" Value="false"&gt;
</span><span class='line'>                            &lt;Setter Property="Opacity" TargetName="border" Value="0.56"/&gt;
</span><span class='line'>                        &lt;/Trigger&gt;
</span><span class='line'>                        &lt;Trigger Property="IsMouseOver" Value="true"&gt;
</span><span class='line'>                            &lt;Setter Property="Background" TargetName="border" Value="{DynamicResource TextBox.MouseOver.Background}"/&gt;
</span><span class='line'>                        &lt;/Trigger&gt;
</span><span class='line'>                        &lt;Trigger Property="IsKeyboardFocused" Value="true"&gt;
</span><span class='line'>                            &lt;Setter Property="BorderBrush" TargetName="border" Value="{DynamicResource TextBox.Focus.Border}"/&gt;
</span><span class='line'>                        &lt;/Trigger&gt;
</span><span class='line'>                    &lt;/ControlTemplate.Triggers&gt;
</span><span class='line'>                &lt;/ControlTemplate&gt;
</span><span class='line'>            &lt;/Setter.Value&gt;
</span><span class='line'>        &lt;/Setter&gt;
</span><span class='line'>        &lt;Style.Triggers&gt;
</span><span class='line'>            &lt;MultiTrigger&gt;
</span><span class='line'>                &lt;MultiTrigger.Conditions&gt;
</span><span class='line'>                    &lt;Condition Property="IsInactiveSelectionHighlightEnabled" Value="false"/&gt;
</span><span class='line'>                    &lt;Condition Property="IsSelectionActive" Value="true"/&gt;
</span><span class='line'>                &lt;/MultiTrigger.Conditions&gt;
</span><span class='line'>                &lt;Setter Property="SelectionBrush" Value="{DynamicResource TextBox.SelectionBrush}"/&gt;
</span><span class='line'>            &lt;/MultiTrigger&gt;
</span><span class='line'>        &lt;/Style.Triggers&gt;
</span><span class='line'>    &lt;/Style&gt;</span></code></pre></td></tr></table></div></figure>


<p>TextBoxまで作成すると、背景色を白ベースか黒ベースかという選択肢も追加できます。</p>

<p>テキストボックスの選択している箇所がブランドカラーになるのも美しいです。</p>

<p><img src="http://s-ueno.github.io/images/wpf-14-03.png" alt="wpf-14-03" /></p>

<p>TextBoxなどはまだ簡単なのですが、ラジオボタン、コンボボックスとなるにつれて、VisualStudioが自動生成してくれる
テンプレートが挑発的です。</p>

<p>次回は、ラジオボタンを紹介します。</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WPF パンくずリストで画面遷移]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/29/wpf-13/"/>
    <updated>2014-11-29T02:35:15+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/29/wpf-13</id>
    <content type="html"><![CDATA[<p>ナビゲーターとしてのインターフェイス + Styleによるパンくずリストの外観を
併せ持つパンくずリストクラスです。</p>

<p><img src="http://s-ueno.github.io/images/wpf-13-01.png" alt="wpf-13-01" /></p>

<!-- more -->


<p>ベースクラスを <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.aspx">ItemsControl</a> とするカスタム コントロールとして作成しました。<br/>
上部にメニューを配置し、中央部がメインコンテンツという最もシンプルなパターンです。</p>

<p>いつものごとく、Styleを利用して グリッド レイアウトで区切っていきます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-13-02.png" alt="wpf-13-02" /></p>

<p>ここで、メインコンテンツと右上部のアイコンは増減しませんが、左上部のパンくずメニューは遷移によって
コンテンツが増減する、 <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.aspx">ItemsControl</a> の実体の部分になります。</p>

<p>この実態部のコンテンツを表すのが <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemspresenter.aspx">ItemsPresenter</a> クラスです。</p>

<p>ItemsControl.Items プロパティにButtonを10個投入した場合、この <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemspresenter.aspx">ItemsPresenter</a> の箇所にButtonが10個表示されます。</p>

<p>ちなみに ItemsControl の実体が ItemsPresenter であり、
ContentControl の実体は ContentPresenter という、シンプルな名前です。</p>

<p>次に Item をどのようなパネルに展開するのかを決定するのが、 ItemsControl.ItemsPanel プロパティです。</p>

<p>メニューなので横に展開することができる <code>&lt;WrapPanel Orientation="Horizontal" /&gt;</code> を指定することで、要件を満たせます。</p>

<p>あとは右上に アイコンボタン(Designed by <a href="http://modernuiicons.com/">Alex Peattie</a> )
中央に ViewModel を指定するとそのViewを表示することができるカスタムの DataTemplateSelector
を指定した ContentPresenter を配置すると カスタム コントロールとしての外観は完成です。</p>

<p>60行程度のとてもシンプルな定義です。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;ui:ViewDataTemplateSelector x:Key="templateSelector" /&gt;
</span><span class='line'>&lt;Style TargetType="{x:Type local:Breadcrumb}"&gt;
</span><span class='line'>    &lt;Setter Property="Focusable" Value="False" /&gt;
</span><span class='line'>    &lt;Setter Property="FocusVisualStyle" Value="{x:Null}"/&gt;
</span><span class='line'>    &lt;Setter Property="KeyboardNavigation.TabNavigation" Value="Local" /&gt;
</span><span class='line'>    &lt;Setter Property="ItemsPanel"&gt;
</span><span class='line'>        &lt;Setter.Value&gt;
</span><span class='line'>            &lt;ItemsPanelTemplate&gt;
</span><span class='line'>                &lt;WrapPanel Orientation="Horizontal" /&gt;
</span><span class='line'>            &lt;/ItemsPanelTemplate&gt;
</span><span class='line'>        &lt;/Setter.Value&gt;
</span><span class='line'>    &lt;/Setter&gt;
</span><span class='line'>    &lt;Setter Property="Template"&gt;
</span><span class='line'>        &lt;Setter.Value&gt;
</span><span class='line'>            &lt;ControlTemplate TargetType="{x:Type local:Breadcrumb}"&gt;
</span><span class='line'>                &lt;Grid Margin="7"&gt;
</span><span class='line'>                    &lt;Grid.RowDefinitions&gt;
</span><span class='line'>                        &lt;RowDefinition Height="auto" /&gt;
</span><span class='line'>                        &lt;RowDefinition Height="*" /&gt;
</span><span class='line'>                    &lt;/Grid.RowDefinitions&gt;
</span><span class='line'>                    &lt;Grid.ColumnDefinitions&gt;
</span><span class='line'>                        &lt;ColumnDefinition Width="auto" /&gt;
</span><span class='line'>                        &lt;ColumnDefinition Width="*" /&gt;
</span><span class='line'>                    &lt;/Grid.ColumnDefinitions&gt;
</span><span class='line'>                    &lt;ItemsPresenter Name="MyPresenter" Margin="20,0" HorizontalAlignment="Left" VerticalAlignment="Center" /&gt;
</span><span class='line'>                    &lt;StackPanel Orientation="Horizontal" HorizontalAlignment="Right" Grid.Column="1"&gt;
</span><span class='line'>                        &lt;Button x:Name="HomeButton" Width="35" Height="35" 
</span><span class='line'>                                HorizontalContentAlignment="Right"
</span><span class='line'>                                Foreground="{DynamicResource AppForeground}"
</span><span class='line'>                                BorderBrush="Transparent"
</span><span class='line'>                                Style="{DynamicResource EllipseButtonStyle}" 
</span><span class='line'>                                &gt;
</span><span class='line'>                            &lt;Viewbox Stretch="Fill"&gt;
</span><span class='line'>                                &lt;Path Style="{DynamicResource PathButtonStyle}"
</span><span class='line'>                                      Data="F1 M 24.0033,56.0078L 24.0033,38.0053L 22.0031,40.0056L 19.0027,35.0049L 38.0053,20.0028L 45.0063,25.5299L 45.0063,21.753L 49.0068,21.0029L 49.0068,28.6882L 57.008,35.0049L 54.0075,40.0056L 52.0073,38.0053L 52.0073,56.0078L 24.0033,56.0078 Z M 38.0053,26.9204L 27.0038,36.005L 27.0038,53.0074L 33.0046,53.0074L 33.0046,42.006L 43.006,42.006L 43.006,53.0074L 49.0068,53.0074L 49.0068,36.005L 38.0053,26.9204 Z " /&gt;
</span><span class='line'>                            &lt;/Viewbox&gt;
</span><span class='line'>                        &lt;/Button&gt;
</span><span class='line'>                        &lt;Button x:Name="NewWindowButton" Width="35" Height="35" 
</span><span class='line'>                                HorizontalContentAlignment="Right"
</span><span class='line'>                                Foreground="{DynamicResource AppForeground}"
</span><span class='line'>                                BorderBrush="Transparent"
</span><span class='line'>                                Style="{DynamicResource EllipseButtonStyle}" 
</span><span class='line'>                                &gt;
</span><span class='line'>                            &lt;Viewbox Stretch="Fill"&gt;
</span><span class='line'>                                &lt;Path Style="{DynamicResource PathButtonStyle}"
</span><span class='line'>                                      Data="F1 M 44.3333,19L 57,19L 57,31.6667L 52.25,36.4167L 52.25,27.7083L 34.8333,45.125L 30.875,41.1667L 48.2917,23.75L 39.5833,23.75L 44.3333,19 Z M 19,25.3333L 42.75,25.3333L 38,30.0833L 23.75,30.0833L 23.75,52.25L 45.9167,52.25L 45.9167,38L 50.6667,33.25L 50.6667,57L 19,57L 19,25.3333 Z " /&gt;
</span><span class='line'>                            &lt;/Viewbox&gt;
</span><span class='line'>                        &lt;/Button&gt;
</span><span class='line'>                    &lt;/StackPanel&gt;
</span><span class='line'>                    &lt;ContentPresenter x:Name="MainContent" Grid.Row="1" Grid.ColumnSpan="2" Margin="10"
</span><span class='line'>                                      Content="{TemplateBinding MainContent}"
</span><span class='line'>                                      ContentTemplateSelector="{StaticResource templateSelector}" /&gt;
</span><span class='line'>                &lt;/Grid&gt;
</span><span class='line'>            &lt;/ControlTemplate&gt;
</span><span class='line'>        &lt;/Setter.Value&gt;
</span><span class='line'>    &lt;/Setter&gt;
</span><span class='line'>&lt;/Style&gt;
</span></code></pre></td></tr></table></div></figure>


<p>ナビゲーターとしてのインターフェイス　+　いつものごとくアニメーションをC#のコード上で実装すれば完成です。</p>

<p>ポイントがいくつかあるので紹介します。</p>

<ul>
<li>MEFの利用</li>
<li>アニメーション</li>
<li>NewWindowボタン</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.weakreference.aspx">WeakReference</a>の利用</li>
</ul>


<h2>MEFの利用</h2>

<p>Use添付プロパティを公開し、trueが設定されると自分自身をMEF経由でインスタンス化するようにしています。</p>

<p><img src="http://s-ueno.github.io/images/wpf-13-03.png" alt="wpf-13-03" /></p>

<p>設定側</p>

<p><img src="http://s-ueno.github.io/images/wpf-13-04.png" alt="wpf-13-04" /></p>

<h2>アニメーション</h2>

<p>パンくずメニューに新しくアイテムが追加されると、画面右側からButtonが飛んでくるアニメーションです。
これもシンプルで ItemsControl.Items プロパティ に Button を Add するタイミングで、 Storyboard を適用すればOKです。</p>

<h2>NewWindowボタン</h2>

<p>LOBアプリでは画面を見比べることもあるだろうと、NewWindowボタンを用意しました。
ボタン押下で表示しているメインコンテンツが新しいWindowsとして起動する機能です。</p>

<p><img src="http://s-ueno.github.io/images/wpf-13-05.png" alt="wpf-13-05" /></p>

<p>今は単純に新しいWindow表示していますが、どこかのタイミングでガバーフローとして
画面をスタックし、アニメーション表示する機能に差し替えたいと思います。</p>

<h2><a href="http://msdn.microsoft.com/ja-jp/library/system.weakreference.aspx">WeakReference</a>の利用</h2>

<p>最後に、<a href="http://msdn.microsoft.com/ja-jp/library/system.weakreference.aspx">WeakReference</a>についてです。</p>

<p>過去に紹介しましたが、親ViewModel が 子ViewModel を New し、それを ListCollectionView 経由で Tab 風に表示させたりしています。
ライフサイクル管理の基本は、Newした人が破棄まで担当するので、この場合は 親ViewModel が子ViewModelの破棄までを担当します。</p>

<p>このときに、ナビゲーターが直接子ViewModelのインスタンスへの参照を持ってしまうと、
メモリに残り続けてガベージコレクタの対象にならないようなことも十分に起こりえます。</p>

<p>ナビゲーターは指示されればViewModelを参照して遷移しますが、その参照は&#8221;弱い参照&#8221;である必要があります。
そこで利用するのが、<a href="http://msdn.microsoft.com/ja-jp/library/system.weakreference.aspx">WeakReference</a>です。</p>

<p>このクラス経由で参照する場合、ガベージコレクタは参照にカウントしないので、不要なメモリリークを防ぐことができます。</p>

<p>あと、いくつかの基本的な機能（TextBox、DataGrid、ToggleButton系）のModern Style化と拡張を紹介できれば、アプリケーション作成に入りたいと思います。</p>

<p>サンプルはコチラ
<a href="https://github.com/s-ueno/uENLab" rel="tooltip" title="uENLab">
  <img class="social_icon" alt="github icon" src="http://s-ueno.github.io/images/glyphicons_381_github.png">
</a></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jekyll の Paginate が仕事しない]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/27/wpf-12/"/>
    <updated>2014-11-27T20:28:15+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/27/wpf-12</id>
    <content type="html"><![CDATA[<p>jekyll-paginate が仕事しない事にここ数日悩まされました&hellip;</p>

<!-- more -->


<p>WPF でパンくずリストを画面遷移に採用したのを執筆したかったのですが
(git 上は開発ブランチからメイン トランクにリリースしました。)
本業で3連休つぶれるし jekyll-paginate が仕事しないし、散々でした。</p>

<p>_config.yml で</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>paginate: 10 
</span><span class='line'>paginate_path: "posts/:num"
</span></code></pre></td></tr></table></div></figure>


<p>と、宣言するとページネーターが 10 記事より過去の記事を 前のページ みたいに
自動生成してくれるハズだったのですが、これが0Byteのファイルしかできなくて（涙）</p>

<p>原因は plugins の category_generator.rb と tag_generator.rb だとわかったのですが
解決の方向性を誤りまして・・・。</p>

<p>なんとか、ジェネレートできないかgemのバージョンやjekyllのrubyのソースにバグがないかとか
index.htmlの構文誤りがないかとか、あさっての方向に全力疾走しまして。</p>

<p>無駄に3夜ほど費やしました。</p>

<p>原因わかってるなら、問題のプラグインをrb.bkか何かにリネームしてページネーターが
ジェネレートした過去記事用のHTMLだけ git にチェックインすればいいのでは？</p>

<p>と気づいたのが今日でした。
それでうまくいったのですが、別のStyleではどうかとテストしてみたところ、またダメでした。</p>

<p>種々のバグ修正しながら、これは ruby を写経しなさいとの啓示かもしれません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MEF で優先度を設けて取得できないか]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/25/wpf-11/"/>
    <updated>2014-11-25T23:22:15+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/25/wpf-11</id>
    <content type="html"><![CDATA[<p><a href="http://msdn.microsoft.com/ja-jp/library/dd460648.aspx">MEF</a> はMSDNだけみて使ってみたのですが、
もう少し使い勝手が良くならないか勉強しました。</p>

<!-- more -->


<p><a href="http://msdn.microsoft.com/ja-jp/library/dd460648.aspx">MEF</a> の基本は、実体化したいオブジェクトの取得元となる情報を <a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.composition.primitives.composablepartcatalog.aspx">ComposablePartCatalog</a> クラスから派生した
<a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.composition.hosting.assemblycatalog.aspx">AssemblyCatalog</a> クラス や<a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.composition.hosting.typecatalog.aspx">TypeCatalog</a> クラス を用いてアセンブリやTypeの情報を
<a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.composition.hosting.compositioncontainer.aspx">CompositionContainer</a> というコンテナに登録、このコンテナから実体化する
ことまでは直観的にわかりました。</p>

<p>ただ、Get××とかCreate××のような如何にもインスタンス取得できそうなメソッドがなく、
MSDNのサンプルでは <a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.composition.attributedmodelservices.composeparts.aspx">container.ComposeParts</a> メソッド 呼び出すことで
メンバーに実体が割り当てられるという、あまり使い勝手がよくない状態でした。</p>

<p>当たり前のDIとして、以下のようなことができないのか</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>interface ITest
</span><span class='line'>{
</span><span class='line'>}
</span><span class='line'>class TestA : ITest
</span><span class='line'>{
</span><span class='line'>}
</span><span class='line'>class TestB : TestA
</span><span class='line'>{
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>static void Sample()
</span><span class='line'>{
</span><span class='line'>//優先度をもってTestA、TestBのいずれかを取得したい
</span><span class='line'>var service = Create&lt;ITest&gt;();
</span></code></pre></td></tr></table></div></figure>


<p>いろいろわかりました。</p>

<p>まず、<a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.composition.attributedmodelservices.composeparts.aspx">container.ComposeParts</a> メソッド を利用しないサービス取得の場合は、Import属性は不要でした。
そもそも、<a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.composition.attributedmodelservices.composeparts.aspx">container.ComposeParts</a> メソッド を利用するシーンの方が少ないような気もします。</p>

<p>何はともあれ、<a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.composition.partcreationpolicyattribute.aspx">PartCreationPolicy属性</a>も付けます。<br/>
この属性を付与しない場合、コンテナからインスタンスを取得するとすべて同じインスタンスを返します。</p>

<p>これがデフォルト動作で、これでは困るので先ほどの属性を利用して、実体化する場合は新しいインスタンスとなるように明示します。</p>

<p>次に <a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.composition.exportmetadataattribute.aspx">ExportMetadata属性</a> でオブジェクトに追加情報を付与します。</p>

<p>以下がサンプルの宣言です。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>[PartCreationPolicy(CreationPolicy.NonShared)]
</span><span class='line'>[ExportMetadata("Priority", 1)]
</span><span class='line'>[Export(typeof(TestA))]
</span><span class='line'>class TestA  { }
</span><span class='line'>
</span><span class='line'>[PartCreationPolicy(CreationPolicy.NonShared)]
</span><span class='line'>[ExportMetadata("Priority", 0)]
</span><span class='line'>[Export(typeof(TestA))]
</span><span class='line'>class TestB : TestA { }</span></code></pre></td></tr></table></div></figure>


<p>ExportMetadata属性で、&#8221;Priority&#8221; という優先度の付加情報を付与しました。<br/>
この取得方法が面白いです。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>public interface IPriority { int Priority { get; } }
</span></code></pre></td></tr></table></div></figure>


<p>このように、&#8221;Priority&#8221; というプロパティ名を持つインターフェイスを宣言します。
ちなみに、このインターフェイスはどこも実装はされていません。</p>

<p>このインターフェイスが判断材料用のオブジェクトとして、コンテナによって動的に実態化されます。</p>

<p>以下がサンプルになります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class Hoge
</span><span class='line'>{
</span><span class='line'>    [PartCreationPolicy(CreationPolicy.NonShared)]
</span><span class='line'>    [ExportMetadata("Priority", 1)]
</span><span class='line'>    [Export(typeof(TestA))]
</span><span class='line'>    class TestA  { }
</span><span class='line'>
</span><span class='line'>    [PartCreationPolicy(CreationPolicy.NonShared)]
</span><span class='line'>    [ExportMetadata("Priority", 0)]
</span><span class='line'>    [Export(typeof(TestA))]
</span><span class='line'>    class TestB : TestA { }
</span><span class='line'>
</span><span class='line'>    public static void Sample()
</span><span class='line'>    {
</span><span class='line'>        var service = Create&lt;TestA&gt;();
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /// &lt;summary&gt;静的コンストラクタ&lt;/summary&gt;
</span><span class='line'>    static Hoge()
</span><span class='line'>    {
</span><span class='line'>        var catalog = new AssemblyCatalog(Assembly.GetExecutingAssembly());
</span><span class='line'>        Container = new CompositionContainer(catalog);
</span><span class='line'>    }
</span><span class='line'>    private static readonly CompositionContainer Container;
</span><span class='line'>
</span><span class='line'>    public interface IPriority { int Priority { get; } }
</span><span class='line'>    public static T Create&lt;T&gt;()
</span><span class='line'>    {
</span><span class='line'>        var list = Container.GetExports&lt;T, IPriority&gt;();
</span><span class='line'>        var mostPriority = list.OrderBy(x =&gt; x.Metadata.Priority)
</span><span class='line'>                               .FirstOrDefault();
</span><span class='line'>        return mostPriority != null ? mostPriority.Value : default(T);
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://msdn.microsoft.com/ja-jp/library/dd833149.aspx">GetExports</a> メソッドの型パラメーター 1 は、取得したい型で、
2つ目の引数は判断材料となる<a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.composition.exportmetadataattribute.aspx">ExportMetadata属性</a> の情報を転送できる
任意のインターフェイスなりクラスとなります。</p>

<p>ここに IPriority インターフェイスを設定すると、コンテナがGUIDを利用して動的クラスを構築、生成し、
そのメンバに属性値を割り当ててくれます。</p>

<p>そのため、その任意の判断材料を利用して複数のクラスからある特定のクラスを返すことができるようになります。</p>

<p>今回は Priority という優先度のサンプルでしたが、たとえばデータベースのサービス名などを文字として
切り分け判断材料に利用すれば、データベース非依存のサービスなどいろいろと応用ができそうです。</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ダイアログ メッセージのデザイン - WPF Vol 09]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/20/wpf-10/"/>
    <updated>2014-11-20T20:28:15+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/20/wpf-10</id>
    <content type="html"><![CDATA[<p>ストア アプリ風のダイアログ メッセージ を作成しました。<br/>
もちろん、アニメーションします。</p>

<p><img src="http://s-ueno.github.io/images/wpf-10-01.png" alt="wpf-10-01" /></p>

<!-- more -->


<p>これも、いつもの如くまずはグリッド デザインから始まります。</p>

<p><img src="http://s-ueno.github.io/images/wpf-10-02.png" alt="wpf-10-02" /></p>

<p>ちなみに図（と、デザイン）は<a href="http://msdn.microsoft.com/ja-jp/jj984295">ココ</a>です。<br/>
(XPS で配布しなさいよ!!@心の声)</p>

<p>Windows 8.1 UX ガイドライン というのが、どこかにあると思います。</p>

<p>さて、話を戻すとWindowのデフォルトStyle上で、グリッドを比率設定してデザインしました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-10-03.png" alt="wpf-10-03" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Grid.RowDefinitions&gt;
</span><span class='line'>    &lt;RowDefinition Height="2*" /&gt;
</span><span class='line'>    &lt;RowDefinition Height="auto" /&gt;
</span><span class='line'>    &lt;RowDefinition Height="2*" /&gt;
</span><span class='line'>&lt;/Grid.RowDefinitions&gt;</span></code></pre></td></tr></table></div></figure>


<p>作業手順ですが、今回のように具体的な図を基にする場合は、Excelにイメージを張り付けた後にセルの数を数えて、6個、3個、6個で比率だと 2対1対2 だね、という大雑把に設定しています。</p>

<p>次に、真ん中のメッセージタイトル、メッセージ内容、ボタンを大まかに区切っていきます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Grid.ColumnDefinitions&gt;
</span><span class='line'>    &lt;ColumnDefinition Width="*" /&gt;
</span><span class='line'>    &lt;ColumnDefinition Width="3*" /&gt;
</span><span class='line'>    &lt;ColumnDefinition Width="*" /&gt;
</span><span class='line'>&lt;/Grid.ColumnDefinitions&gt;
</span></code></pre></td></tr></table></div></figure>


<p>あとは、このVisibilityをVisibleにすると同時にアニメーションすれば完成です。
ちなみにこれを呼び出す側はViewModelに用意した拡張メソッドをCallするだけです。</p>

<p><img src="http://s-ueno.github.io/images/wpf-10-04.png" alt="wpf-10-04" /></p>

<p>今回のポイントは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.input.keyboardnavigation.aspx">KeyboardNavigation</a> クラスを利用した各種添付プロパティです。</p>

<p><img src="http://s-ueno.github.io/images/wpf-10-05.png" alt="wpf-10-05" /></p>

<p>メッセージ ダイアログなので、デフォルトでフォーカスがあたるボタンがあります。<br/>
この時にボタン以外にフォーカスが当たると困ります。</p>

<p>MSDNを見ると</p>

<blockquote><p>KeyboardNavigation  クラスは、ナビゲーション キーのいずれかが押されたときに、既定のキーボード フォーカスのナビゲーションを実装します。 ナビゲーション キーとは、Tab、Shift + Tab、Ctrl + Tab、Ctrl + Shift + Tab、上方向、下方向、左方向、および右方向の各キーを指します。</p></blockquote>

<p>とあります。</p>

<p>これらのキーを押してもボタン群だけフォーカスが当たるように添付プロパティを設定しています。</p>

<p>いつものごとく、サンプル成果物はGit管理で。</p>

<p><a href="https://github.com/s-ueno/uENLab">@s-ueno/uENLab</a> on GitHub</p>

<p>次回は画面遷移を考えてみます。</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[カスタムコントロールとおまけでIsolatedStorage - WPF Vol 08]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/20/wpf-09/"/>
    <updated>2014-11-20T02:02:02+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/20/wpf-09</id>
    <content type="html"><![CDATA[<p>カスタム コントロールを作成して TabControlと置き換えてみました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-09-01.png" alt="wpf-09-01" /></p>

<!-- more -->


<p>前回はユーザーコントロールでしたが、今度はカスタムコントロールです。</p>

<p>VisualStudioで新しい項目の追加を選択すると</p>

<p><img src="http://s-ueno.github.io/images/wpf-09-02.png" alt="wpf-09-02" /></p>

<p>ユーザーコントロールとは別にカスタムコントロールが選べます。</p>

<p>ユーザーコントロールでは、Xamlファイル+コードビハインドが追加されました。
カスタムコントロールでは、csファイルがメインで、そのStyleリソースがプロジェクト直下にThemesフォルダとGeneric.xamlという形で追加されます。</p>

<p>TabControlの代わりにListContentカスタムコントロールを作成します。<br/>
追加されたGeneric.xamlはListContent.Xamlに名前を変更しました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-09-03.png" alt="wpf-09-03" /></p>

<p>csファイルの中身は、静的コンストラクタとデフォルトスタイル キーの宣言、長いコメントが付いてきます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-09-04.png" alt="wpf-09-04" /></p>

<p>ベースクラスはControlクラスから<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.selector.aspx">Selector</a> クラスに変更しました。</p>

<p>Controlクラスから複数のアイテムを操作するための一連の機能を実装しているItemsControl、さらにそこに選択するという一連の依存関係プロパティを実装しているSelectorクラスを、今回のベースクラスとして採用しています。</p>

<p>Tabコントロールと同等レベルでよければ、このcsファイルは何も実装しなくても問題ありません。
追加されたリソースディクショナリにXamlでStyleとTemplateを実装していくと、それだけで問題なく動作できます。</p>

<p>ちなみに、これを利用するアプリケーション側は1行、TabControlからListContentに書き換えるだけです。</p>

<p><img src="http://s-ueno.github.io/images/wpf-09-05.png" alt="wpf-09-05" /></p>

<p>あとは、デザインをイメージしてXamlのスタイルを記述していきます。<br/>
今回は上部に各タブのタイトルが並び、それを選択するとメインコンテンツに対象のViewが表示される形です。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;ui:ViewDataTemplateSelector x:Key="templateSelector" /&gt;
</span><span class='line'>&lt;Style TargetType="{x:Type local:ListContent}"&gt;
</span><span class='line'>    &lt;Setter Property="Focusable" Value="False" /&gt;
</span><span class='line'>    &lt;Setter Property="FocusVisualStyle" Value="{x:Null}"/&gt;
</span><span class='line'>    &lt;Setter Property="KeyboardNavigation.TabNavigation" Value="Local" /&gt;
</span><span class='line'>    &lt;Setter Property="Template"&gt;
</span><span class='line'>        &lt;Setter.Value&gt;
</span><span class='line'>            &lt;ControlTemplate TargetType="{x:Type local:ListContent}"&gt;
</span><span class='line'>                &lt;Grid&gt;
</span><span class='line'>                    &lt;Grid.RowDefinitions&gt;
</span><span class='line'>                        &lt;RowDefinition Height="auto" /&gt;
</span><span class='line'>                        &lt;RowDefinition Height="*" /&gt;
</span><span class='line'>                    &lt;/Grid.RowDefinitions&gt;
</span><span class='line'>                    &lt;ListBox x:Name="TitleContent" 
</span><span class='line'>                             Background="Transparent"
</span><span class='line'>                             HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
</span><span class='line'>                             ItemsSource="{TemplateBinding ItemsSource}"
</span><span class='line'>                             ItemContainerStyle="{StaticResource ListContentHeaderStyle}"
</span><span class='line'>                             &gt;
</span><span class='line'>                        &lt;ListBox.ItemsPanel&gt;
</span><span class='line'>                            &lt;ItemsPanelTemplate&gt;
</span><span class='line'>                                &lt;WrapPanel Orientation="Horizontal"/&gt;
</span><span class='line'>                            &lt;/ItemsPanelTemplate&gt;
</span><span class='line'>                        &lt;/ListBox.ItemsPanel&gt;
</span><span class='line'>                    &lt;/ListBox&gt;
</span><span class='line'>                    &lt;ContentPresenter x:Name="MainContent" Grid.Row="1" 
</span><span class='line'>                                      Content="{TemplateBinding SelectedItem}"
</span><span class='line'>                                      ContentTemplateSelector="{StaticResource templateSelector}" /&gt;
</span><span class='line'>                &lt;/Grid&gt;
</span><span class='line'>            &lt;/ControlTemplate&gt;
</span><span class='line'>        &lt;/Setter.Value&gt;
</span><span class='line'>    &lt;/Setter&gt;
</span><span class='line'>&lt;/Style&gt;</span></code></pre></td></tr></table></div></figure>


<p>ポイントがいくつかあります。</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.input.keyboardnavigation.tabnavigation.aspx">KeyboardNavigation.TabNavigation</a> 添付プロパティ</li>
<li>ListBox</li>
<li>ContentPresenter</li>
</ul>


<h2><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.input.keyboardnavigation.tabnavigation.aspx">KeyboardNavigation.TabNavigation</a> 添付プロパティ</h2>

<p>WPFはツリー構造なのでTabを押下していくと最初にトップレベルのコンテンツにタブが移動してきます。そこで、この添付プロパティ値をLocal設定すると、Tabで今回作成したListContentにフォーカスが入った際に、次のコンテンツではなく、ListContent内部へTabが移動するようになります。</p>

<h2>ListBox / <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.itemcontainerstyle.aspx">ListBox.ItemContainerStyle</a></h2>

<p>今回は上部にヘッダー用のメニューをデザインしています。
ListContentはベースクラスにItemsControlを持つので、そこにバインドされたコレクションの一覧を持ちます。</p>

<p>その一覧をListBoxのItemsSourceにTemplateBindingで転送しています。
ListBoxなので、各行のスタイルを自由にデザインできます。
このスタイルが、上部のメニューのスタイルになります。そのStyleを決定するのが<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.itemcontainerstyle.aspx">ListBox.ItemContainerStyle</a>プロパティです。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;ListBox.ItemContainerStyle&gt;
</span><span class='line'>  &lt;Style TargetType="{x:Type ListBoxItem}"&gt;</span></code></pre></td></tr></table></div></figure>


<p>として直接記述することもできますし、<code>&lt;Style  x:Key="ListContentHeaderStyle" TargetType="{x:Type ListBoxItem}"&gt;</code> として別の箇所に記述したものを利用することもできます。</p>

<p>今回は整理するためにも後述の別箇所に切り出しました。</p>

<p>そのStyleも淡々とデザインします。
アイコンを設定できる枠を用意してもいいし、選択されているときだけ背景色を設定するとかでもいいかもしれません。</p>

<h2>ContentPresenter</h2>

<p>Contentには選択してるアイテムをTemplateBindingで転送しています。<br/>
その実態はバインド ソースである <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.listcollectionview.aspx">ListCollectionView</a> 経由でViewModelコレクションの中の選択されている一つです。</p>

<p>ContentTemplateSelectorプロパティを利用することで、コンテンツをどう表示させるかを選択させています。</p>

<p>この仕組みだけで表示はできるのですが、コンテンツの細かい一つ一つをどう表示するかを作りこむことで、ユーザーに体感してもらうことができます。</p>

<p>今回はメニューの一つ一つが滑らかなアニメーションで表示されるように作りこみました。<br/>
些細なことですが、シンプルでも退屈させず、それがコンテンツであることを認識してもらうことができます。</p>

<p>今回はアニメーションの作りこみのために、ListContent.csファイルにコードを追加しています。
アニメーションは<a href="http://msdn.microsoft.com/ja-jp/library/ms742868.aspx">Storyboard</a> クラス、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.media.animation.animationtimeline.aspx#inheritanceContinued">AnimationTimeline</a> クラスと利用するのですが、滑らかにするためのコツとして<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.media.animation.easingfunctionbase.aspx#inheritanceContinued">イージング関数</a>があります。</p>

<p>機械的な動作ではなく、慣性的なアニメーションで滑らかな印象を与えることができます。</p>

<p>XAMLは技術依存ですが資産としてクラス ライブラリに集めていくと、利用するアプリケーション開発は自動でポリシーのように利用できるようになります。</p>

<p>いくつかの基本的な技術資産を実装した段階で、具体的なアプリケーションの作成を考えています。
その際にはラフでいい加減なユースケース シナリオを用いたお手軽分析しながら作成したいと思います。</p>

<p>代表的な残りは・・・</p>

<ul>
<li>ストアアプリ風メッセージボックス</li>
<li>画面遷移</li>
<li>例外専用ダイアログ</li>
<li>TextBox

<ul>
<li>Modern Style化</li>
<li>IMEの注入</li>
<li>型桁対応</li>
<li>AutoComplete</li>
</ul>
</li>
<li>DataGrid

<ul>
<li>Modern Style化</li>
</ul>
</li>
<li>ToggleButton系</li>
<li>ComboBox</li>
</ul>


<p>などでしょうか。</p>

<h2><a href="http://msdn.microsoft.com/ja-jp/library/system.io.isolatedstorage.aspx">IsolatedStorage</a></h2>

<p>おまけで、紹介します。</p>

<p>MSDNを見てもよくわかりませんが、簡単に言うとアプリケーション毎のセキュアな読書用Streamを与えてくれる機能です。Streamなので、具体的なファイルパスを意識する必要がないのが便利です。</p>

<p>また、実際に永続化してくれているので、アプリケーションの次回起動時にその情報を利用できます。</p>

<p>今回は拡張メソッドで用意しました。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>    public static class BackingStore
</span><span class='line'>    {
</span><span class='line'>        public static void SetBackingStore&lt;T&gt;(this T obj, object value, [CallerMemberName] string key = null) where T : class
</span><span class='line'>        {
</span><span class='line'>            var appStore = IsolatedStorageFile.GetUserStoreForAssembly();
</span><span class='line'>            var directoryPath = typeof(T).FullName;
</span><span class='line'>            if (!appStore.DirectoryExists(directoryPath))
</span><span class='line'>            {
</span><span class='line'>                appStore.CreateDirectory(directoryPath);
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            using (var stream = new IsolatedStorageFileStream(Path.Combine(directoryPath, key), FileMode.OpenOrCreate, appStore))
</span><span class='line'>            {
</span><span class='line'>                var formatter = new BinaryFormatter();
</span><span class='line'>                formatter.Serialize(stream, value);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        public static object GetBackingStore&lt;T&gt;(this T obj, [CallerMemberName] string key = null) where T : class
</span><span class='line'>        {
</span><span class='line'>            var appStore = IsolatedStorageFile.GetUserStoreForAssembly();
</span><span class='line'>            var directoryPath = typeof(T).FullName;
</span><span class='line'>            if (!appStore.DirectoryExists(directoryPath))
</span><span class='line'>            {
</span><span class='line'>                appStore.CreateDirectory(directoryPath);
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            object result = null;
</span><span class='line'>            try
</span><span class='line'>            {
</span><span class='line'>                using (var stream = new IsolatedStorageFileStream(Path.Combine(directoryPath, key), FileMode.OpenOrCreate, appStore))
</span><span class='line'>                {
</span><span class='line'>                    var formatter = new BinaryFormatter();
</span><span class='line'>                    result = formatter.Deserialize(stream);
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>            catch (Exception ex)
</span><span class='line'>            {
</span><span class='line'>
</span><span class='line'>            }
</span><span class='line'>            return result;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        public static void RemoveBackingStore&lt;T&gt;(this T obj) where T : class
</span><span class='line'>        {
</span><span class='line'>            var appStore = IsolatedStorageFile.GetUserStoreForAssembly();
</span><span class='line'>            appStore.Remove();
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>


<p>プロパティのバッキングストアのように利用します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public int MyProperty
</span><span class='line'>{
</span><span class='line'>    get { return (int)this.GetBackingStore(); }
</span><span class='line'>    set { this.SetBackingStore(value); }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>ただ FileIOしますし、排他制御もしていないので、マルチスレッドはもちろん頻繁にアクセスするような機能でないことは確かです。</p>

<p>今回はSettingで選択した情報を保存・復元する機能を持ちます。
具体的な永続化の場所はユーザーのAppDataフォルダの中に保存されています。</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ユーザーコントロールに学ぶ様々なコンテンツ - WPF Vol 07]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/17/wpf-08/"/>
    <updated>2014-11-17T19:44:57+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/17/wpf-08</id>
    <content type="html"><![CDATA[<p>設定メニューの作成を通じて、ユーザーコントロールについて紹介します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-08-01.png" alt="wpf-08-01" /></p>

<!-- more -->


<p>WPFは柔軟で StyleやTemplate、添付プロパティで多くは対応できるのですが、場合によっては以下のようなレベルでコントロールを作成する場面も出てきます。</p>

<ul>
<li>ユーザーコントロール</li>
<li>カスタムコントロール</li>
<li>カスタム要素</li>
</ul>


<p><a href="http://msdn.microsoft.com/ja-jp/library/ms745025.aspx">MSDNにも記載</a>があります。</p>

<p>また、これらをクラス ライブラリとして開発する場合と、アプリケーションとして開発する場合で適用するプログラミング デザインパターンも変わってきます。</p>

<p>本シリーズのビューの基本クラスとなるBizViewクラスはUserControl派生です。
その基本機能を実装する上でMVVMパターンで作成しているかといえば、クラスライブラリとしての基本セットなのでそうではありません。</p>

<h2>ユーザーコントロール</h2>

<p>VisualStudioで、新しい項目を追加する場合に選択できます。<br/>
ベースクラスがUserControlクラスになります。</p>

<p>主な目的は、より要件に具体的なビューを提供済みのコンテンツを組み合わせて構築することです。<br/>
たとえば、BizViewクラスから派生したView/ViewModelの各種コンテンツ(サンプルのVol04View/Vol05Viewなど)も同様に、目的とする画面をボタンやラベルといった提供済みコンテンツを配置して作成しています。</p>

<p>それと比べて、カスタムコントロールやカスタム要素は、WPFの組込済みコントロール(Buttonのベースクラスは)がそうであるように、基本となるコンテンツ作成として利用します。</p>

<p>FrameworkElement派生ではパフォーマンスが向上しますが、実装する際には <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.media.drawingvisual.aspx">DrawingVisual</a> クラスなどを利用して、描画を実装する必要が出てきます。</p>

<p>さて、今回は画面の右側に表示する設定画面をユーザーコントロールで作成します。<br/>
画面は以下の構成で、コンテンツ部には指定したView/ViewModelのセットが追加できるよう検討します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-08-03.png" alt="wpf-08-03" /></p>

<p>ユーザーコントロールなので、Xamlで画面を開発する要領で作成します。</p>

<p>Xamlも上から下まで30行程度です。</p>

<ul>
<li>グリッドをデザイン通りに上下分割</li>
<li>上部にタイトルとアイコン</li>
<li>下部に設定タイトル一覧とメインコンテンツ</li>
</ul>


<p>を配置しています。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;UserControl x:Class="uEN.UI.Controls.Settings"
</span><span class='line'>             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
</span><span class='line'>             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
</span><span class='line'>             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
</span><span class='line'>             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
</span><span class='line'>             xmlns:uen="clr-namespace:uEN.UI"
</span><span class='line'>             mc:Ignorable="d" 
</span><span class='line'>             Background="{DynamicResource AppBrand}"
</span><span class='line'>             Foreground="White"
</span><span class='line'>             BorderBrush="Transparent"
</span><span class='line'>             d:DesignHeight="300" d:DesignWidth="300"&gt;
</span><span class='line'>    &lt;UserControl.Resources&gt;
</span><span class='line'>        &lt;uen:ViewDataTemplateSelector x:Key="templateSelector" /&gt;
</span><span class='line'>    &lt;/UserControl.Resources&gt;
</span><span class='line'>    &lt;Grid&gt;
</span><span class='line'>        &lt;Grid.RowDefinitions&gt;
</span><span class='line'>            &lt;RowDefinition Height="auto"/&gt;
</span><span class='line'>            &lt;RowDefinition Height="*"/&gt;
</span><span class='line'>        &lt;/Grid.RowDefinitions&gt;
</span><span class='line'>        &lt;StackPanel Margin="10,30,0,30" Orientation="Horizontal"&gt;
</span><span class='line'>            &lt;Button x:Name="IconButton" Width="35" Height="35" Margin="5" 
</span><span class='line'>                    Foreground="White"
</span><span class='line'>                    BorderBrush="White"
</span><span class='line'>                    Style="{DynamicResource EllipseButtonStyle}" 
</span><span class='line'>                    &gt;
</span><span class='line'>                &lt;Viewbox Stretch="Fill"&gt;
</span><span class='line'>                    &lt;Path Style="{DynamicResource PathButtonStyle}"
</span><span class='line'>                          Data="F1 M 33.6458,38L 49.4792,53.8333L 38.7917,53.8333L 22.1667,38L 38.7917,22.1667L 49.4792,22.1667L 33.6458,38 Z "/&gt;
</span><span class='line'>                &lt;/Viewbox&gt;
</span><span class='line'>            &lt;/Button&gt;
</span><span class='line'>            &lt;TextBlock x:Name="Caption" Text="Settings" FontSize="20" VerticalAlignment="Center"/&gt;
</span><span class='line'>        &lt;/StackPanel&gt;
</span><span class='line'>        &lt;ListBox Grid.Row="1" x:Name="SettingViewModels" Visibility="Visible" /&gt;
</span><span class='line'>        &lt;ContentPresenter Grid.Row="1" x:Name="ViewModelPresenter"  
</span><span class='line'>                          ContentTemplateSelector="{StaticResource templateSelector}"
</span><span class='line'>                          /&gt;
</span><span class='line'>    &lt;/Grid&gt;
</span><span class='line'>&lt;/UserControl&gt;
</span></code></pre></td></tr></table></div></figure>


<p>アイコンのジオメトリも前回同様に<a href="http://modernuiicons.com/">Alex Peattie</a>さんのものを利用しています。</p>

<p>ボタンは丸く描画されるように <code>Style="{DynamicResource EllipseButtonStyle}"</code> としてスタイルをリソースとして切り出し、コンテンツにジオメトリを設定しています。</p>

<p>切り出したスタイルは単に  <code>&lt;Setter Property="Template"&gt;</code> としてControlTemplateを設定する際に、Mindwos 8 Styleではフラットで角なしの線を描画するために <code>&lt;Border&gt;</code> としましたが、これを <code>&lt;Ellipse&gt;</code> として丸にすればそれだけでOKです。</p>

<p>ボタンを押したときの内部動作はコードビハインド上で記述しています。<br/>
(クラス ライブラリとしての開発)</p>

<p>アプリケーション構成ファイルに任意のViewModelを設定すると、それが設定画面の一覧に表示されるようにしました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-08-04.png" alt="wpf-08-04" /></p>

<p>あとは、これをWindow Style で定義しているグリッド上にコンテンツとして配置するだけです。</p>

<h2>アニメーション</h2>

<p>ボタンを押下する度に先ほど作成したユーザーコントロールがWindowとしてモーダル表示されたり、画面上にパッとでたり消えたりするのは、利用者としては新鮮さにかけます。
XAMLで作成するアプリケーションのゴールは、やはり柔軟なアニメーションを利用者に体験してもらうことにあります。</p>

<p>今回は、そんなアニメーションを添付プロパティとして切り出して実装しています。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  public enum TransitionStyle
</span><span class='line'>    {
</span><span class='line'>        None,
</span><span class='line'>
</span><span class='line'>        Slide,
</span><span class='line'>        VerticalSlide,
</span><span class='line'>
</span><span class='line'>        SlideOut,
</span><span class='line'>        VerticalSlideOut,
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public class ViewTransition
</span><span class='line'>    {
</span><span class='line'>        public static TransitionStyle GetTransitionStyle(DependencyObject obj)
</span><span class='line'>        {
</span><span class='line'>            return (TransitionStyle)obj.GetValue(TransitionStyleProperty);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        public static void SetTransitionStyle(DependencyObject obj, TransitionStyle value)
</span><span class='line'>        {
</span><span class='line'>            obj.SetValue(TransitionStyleProperty, value);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // Using a DependencyProperty as the backing store for TransitionStyle.  This enables animation, styling, binding, etc...
</span><span class='line'>        public static readonly DependencyProperty TransitionStyleProperty =
</span><span class='line'>            DependencyProperty.RegisterAttached("TransitionStyle", typeof(TransitionStyle), typeof(ViewTransition), new UIPropertyMetadata(TransitionStyle.None, OnTransitionStyleChanged));
</span><span class='line'>
</span><span class='line'>        private static void OnTransitionStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
</span><span class='line'>        {
</span><span class='line'>            var fw = d as FrameworkElement;
</span><span class='line'>            var style = e.NewValue as TransitionStyle?;
</span><span class='line'>            if (!style.HasValue || style == TransitionStyle.None)
</span><span class='line'>                return;
</span><span class='line'>
</span><span class='line'>            fw.Loaded -= fw_Loaded;
</span><span class='line'>            fw.Loaded += fw_Loaded;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        static void fw_Loaded(object sender, RoutedEventArgs e)
</span><span class='line'>        {
</span><span class='line'>            var fw = (FrameworkElement)sender;
</span><span class='line'>            var style = GetTransitionStyle(fw);
</span><span class='line'>
</span><span class='line'>            Play(fw, style);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        public static Storyboard Play(FrameworkElement target, TransitionStyle style, Action completedAction = null)
</span><span class='line'>        {
</span><span class='line'>            Storyboard storyboard = null;
</span><span class='line'>            switch (style)
</span><span class='line'>            {
</span><span class='line'>                case TransitionStyle.None:
</span><span class='line'>                    break;
</span><span class='line'>                case TransitionStyle.Slide:
</span><span class='line'>                    storyboard = CreateSlideStoryboard();
</span><span class='line'>                    break;
</span><span class='line'>                case TransitionStyle.VerticalSlide:
</span><span class='line'>                    storyboard = CreateVerticalSlideStoryboard();
</span><span class='line'>                    break;
</span><span class='line'>                case TransitionStyle.SlideOut:
</span><span class='line'>                    storyboard = CreateSlideStoryboard(false);
</span><span class='line'>                    break;
</span><span class='line'>                case TransitionStyle.VerticalSlideOut:
</span><span class='line'>                    storyboard = CreateVerticalSlideStoryboard(false);
</span><span class='line'>                    break;
</span><span class='line'>                default:
</span><span class='line'>                    break;
</span><span class='line'>            }
</span><span class='line'>            if (completedAction != null)
</span><span class='line'>                storyboard.Completed += (x, y) =&gt; completedAction();
</span><span class='line'>            storyboard.Begin(target);
</span><span class='line'>            return storyboard;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        private static Storyboard CreateSlideStoryboard(bool isFadeIn = true)
</span><span class='line'>        {
</span><span class='line'>            var storyboard = new Storyboard();
</span><span class='line'>
</span><span class='line'>            var fromThickness = isFadeIn ? new Thickness(30, 0, -30, 0) : new Thickness(0);
</span><span class='line'>            var toThickness = isFadeIn ? new Thickness(0) : new Thickness(30, 0, -30, 0);
</span><span class='line'>
</span><span class='line'>            var slideAnimation = new ThicknessAnimation();
</span><span class='line'>            slideAnimation.From = fromThickness;
</span><span class='line'>            slideAnimation.To = toThickness;
</span><span class='line'>            slideAnimation.Duration = new Duration(TimeSpan.FromSeconds(0.3));
</span><span class='line'>
</span><span class='line'>            Storyboard.SetTargetProperty(slideAnimation, new PropertyPath(FrameworkElement.MarginProperty));
</span><span class='line'>            storyboard.Children.Add(slideAnimation);
</span><span class='line'>
</span><span class='line'>            var fromOpacity = isFadeIn ? 0 : 1;
</span><span class='line'>            var toOpacity = isFadeIn ? 1 : 0;
</span><span class='line'>
</span><span class='line'>            var opacityAnimation = new DoubleAnimation();
</span><span class='line'>            opacityAnimation.From = fromOpacity;
</span><span class='line'>            opacityAnimation.To = toOpacity;
</span><span class='line'>            opacityAnimation.Duration = new Duration(TimeSpan.FromSeconds(0.5));
</span><span class='line'>            Storyboard.SetTargetProperty(opacityAnimation, new PropertyPath(FrameworkElement.OpacityProperty));
</span><span class='line'>            storyboard.Children.Add(opacityAnimation);
</span><span class='line'>
</span><span class='line'>            return storyboard;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        private static Storyboard CreateVerticalSlideStoryboard(bool isFadeIn = true)
</span><span class='line'>        {
</span><span class='line'>            var storyboard = new Storyboard();
</span><span class='line'>
</span><span class='line'>            var fromThickness = isFadeIn ? new Thickness(0, 30, 0, -30) : new Thickness(0);
</span><span class='line'>            var toThickness = isFadeIn ? new Thickness(0) : new Thickness(0, 30, 0, -30);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>            var slideAnimation = new ThicknessAnimation();
</span><span class='line'>            slideAnimation.From = fromThickness;
</span><span class='line'>            slideAnimation.To = toThickness;
</span><span class='line'>            slideAnimation.Duration = new Duration(TimeSpan.FromSeconds(0.3));
</span><span class='line'>
</span><span class='line'>            Storyboard.SetTargetProperty(slideAnimation, new PropertyPath(FrameworkElement.MarginProperty));
</span><span class='line'>            storyboard.Children.Add(slideAnimation);
</span><span class='line'>
</span><span class='line'>            var fromOpacity = isFadeIn ? 0 : 1;
</span><span class='line'>            var toOpacity = isFadeIn ? 1 : 0;
</span><span class='line'>
</span><span class='line'>            var opacityAnimation = new DoubleAnimation();
</span><span class='line'>            opacityAnimation.From = fromOpacity;
</span><span class='line'>            opacityAnimation.To = toOpacity;
</span><span class='line'>            opacityAnimation.Duration = new Duration(TimeSpan.FromSeconds(0.5));
</span><span class='line'>            Storyboard.SetTargetProperty(opacityAnimation, new PropertyPath(FrameworkElement.OpacityProperty));
</span><span class='line'>            storyboard.Children.Add(opacityAnimation);
</span><span class='line'>
</span><span class='line'>            return storyboard;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>


<p>Xaml上で設定すれば、コンテンツの読み込み時に自動でアニメーションをするようになります。</p>

<p><img src="http://s-ueno.github.io/images/wpf-08-05.png" alt="wpf-08-05" /></p>

<p>また静的メソッドを利用して、任意のタイミングでも動作します。</p>

<h2>まとめ</h2>

<p>ユーザーコントロールで作成したストアアプリスタイルの設定画面を設け、スタイルの変更ができるようになりました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-08-06.png" alt="wpf-08-06" /></p>

<p><img src="http://s-ueno.github.io/images/wpf-08-07.png" alt="wpf-08-07" /></p>

<p>ただし、設定したユーザー固有のスタイルはまだ永続化していません。<br/>
また、TabControlを利用していますが、このコンテンツはどうしても旧来のWindows Formを彷彿させる、モダンではないビシュアルです。</p>

<p>次回の宿題は、ユーザー固有のスタイルは <a href="http://msdn.microsoft.com/ja-jp/library/system.io.isolatedstorage.aspx">IsolatedStorage</a> の機能を利用して永続化したいと思います。
それと、Controlから派生したItemsControlを利用して、モダンなカスタム コントロールを作成したいと思います。</p>

<p>サンプル成果物はGit管理で。</p>

<p><a href="https://github.com/s-ueno/uENLab">@s-ueno/uENLab</a> on GitHub</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windowに学ぶテンプレートと添付プロパティ - WPF Vol 06]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/15/wpf-07/"/>
    <updated>2014-11-15T03:19:00+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/15/wpf-07</id>
    <content type="html"><![CDATA[<p>従来型の開発ではButtonクラスの外観や機能を変更したい場合は、派生させButtonExカスタムコントロールを作成していました。
しかし前回紹介したように、XamlではButtonクラスにスタイルとテンプレートを適用することで、外観をカスタマイズできることを確認しました。</p>

<p>では今度は Window をストアアプリのようなモダンなものに変えたいと思います。
また、スタイルだけではなくそこで発生するイベントも添付プロパティを利用して、外部から制御したいと思います。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-01.png" alt="wpf-07-01" /></p>

<!-- more -->


<p>イメージのWindowは <code>var window = new Window();</code> としているだけで、特にStyleを明示的に設定はしていません。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.application.aspx">System.Windows.Application</a> クラスのリソースに、 <code>&lt;Style TargetType="{x:Type Window}"&gt;</code> と宣言しているリソースディクショナリを登録しているため、デフォルトでこのスタイルで表示されるようになっています。</p>

<p>次に、MSDN で <a href="http://msdn.microsoft.com/ja-jp/library/ms748948.aspx">WPF ウィンドウの概要</a> として紹介している以下の図がわかりやすいのですが</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-02.png" alt="wpf-07-02" /></p>

<p>最小・最大ボタンや境界線などデフォルトで表示されるものをOFFにし、Windowクラスの外観であるクライアント領域内ですべて実装しています。</p>

<p> <code>&lt;Setter Property="Template"&gt;</code> とTemplateを差し替える前までは、お決まりのスタイルである、前景色、背景色、フォントなどをDynamicResource で設定します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
</span><span class='line'>                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
</span><span class='line'>                     xmlns:local="clr-namespace:uEN.UI.AttachedProperties"
</span><span class='line'>                    &gt;
</span><span class='line'>    &lt;Style TargetType="{x:Type Window}"&gt;
</span><span class='line'>        &lt;Setter Property="Foreground"                   Value="{DynamicResource AppForeground}"/&gt;
</span><span class='line'>        &lt;Setter Property="FontFamily"                   Value="{DynamicResource AppFont}"/&gt;
</span><span class='line'>        &lt;Setter Property="FontSize"                     Value="{DynamicResource AppFontSize}"/&gt;
</span><span class='line'>        &lt;Setter Property="Background"                   Value="{DynamicResource WindowTheme}"/&gt;
</span><span class='line'>        &lt;Setter Property="BorderBrush"                  Value="{DynamicResource AppBrand}"/&gt;
</span><span class='line'>        &lt;Setter Property="BorderThickness"              Value="3" /&gt;
</span><span class='line'>        &lt;Setter Property="Focusable"                    Value="False" /&gt;
</span><span class='line'>        &lt;Setter Property="FocusVisualStyle"             Value="{x:Null}"/&gt;
</span><span class='line'>        &lt;Setter Property="WindowStyle"                  Value="None" /&gt;
</span><span class='line'>        &lt;Setter Property="AllowsTransparency"           Value="True" /&gt;
</span><span class='line'>        &lt;Setter Property="ResizeMode"                   Value="CanResizeWithGrip" /&gt;
</span><span class='line'>        &lt;Setter Property="WindowChrome.WindowChrome"&gt;
</span><span class='line'>            &lt;Setter.Value&gt;
</span><span class='line'>                &lt;WindowChrome ResizeBorderThickness="10" /&gt;
</span><span class='line'>            &lt;/Setter.Value&gt;
</span><span class='line'>        &lt;/Setter&gt;
</span><span class='line'>        &lt;Setter Property="Template"&gt;
</span><span class='line'>            &lt;Setter.Value&gt;
</span><span class='line'>                &lt;ControlTemplate TargetType="{x:Type Window}"&gt;
</span><span class='line'>                    &lt;Border BorderBrush="{TemplateBinding BorderBrush}" 
</span><span class='line'>                            BorderThickness="{TemplateBinding BorderThickness}" 
</span><span class='line'>                            Background="{TemplateBinding Background}"&gt;
</span><span class='line'>                        &lt;Grid x:Name="PART_rootGrid"&gt;
</span><span class='line'>                            &lt;Grid.RowDefinitions&gt;
</span><span class='line'>                                &lt;RowDefinition Height="auto"/&gt;
</span><span class='line'>                                &lt;RowDefinition Height="*"/&gt;
</span><span class='line'>                                &lt;RowDefinition Height="auto"/&gt;
</span><span class='line'>                            &lt;/Grid.RowDefinitions&gt;
</span><span class='line'>                            &lt;Grid.ColumnDefinitions&gt;
</span><span class='line'>                                &lt;ColumnDefinition Width="*"/&gt;
</span><span class='line'>                            &lt;/Grid.ColumnDefinitions&gt;
</span><span class='line'>                   ・
</span><span class='line'>                   ・
</span><span class='line'>                   ・</span></code></pre></td></tr></table></div></figure>


<p>BorderBrush、BorderThicknessは、<code>&lt;Setter Property="Template"&gt;</code> でこれから差し替えるControlTemplate の最初に</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;ControlTemplate TargetType="{x:Type Window}"&gt;
</span><span class='line'>    &lt;Border BorderBrush="{TemplateBinding BorderBrush}" 
</span><span class='line'>            BorderThickness="{TemplateBinding BorderThickness}" 
</span><span class='line'>            Background="{TemplateBinding Background}"&gt;</span></code></pre></td></tr></table></div></figure>


<p>としてBorderを用意しTemplateBindingでバインドすることで、画像のように全体の枠線が色付きで表示されるようになっています。</p>

<p>WindowStyleをNone、AllowsTransparencyをTrueとすることで、境界線や最小最大化ボタンの領域が見えなくなります。
ただ、それではWindowを動かせなくなることや、大きさを変更できなくなるので、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.shell.windowchrome.windowchrome.aspx">WindowChrome.WindowChrome</a> 添付プロパティを利用して、Windowの大きさを変更できるための領域幅を指定した新しいWindowChromeを設定しています。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!-- WindowChromeは.Net4.5から提供されている機能 --&gt;
</span><span class='line'>&lt;Setter Property="WindowChrome.WindowChrome"&gt;
</span><span class='line'>    &lt;Setter.Value&gt;
</span><span class='line'>        &lt;WindowChrome ResizeBorderThickness="10" /&gt;
</span><span class='line'>    &lt;/Setter.Value&gt;
</span><span class='line'>&lt;/Setter&gt;</span></code></pre></td></tr></table></div></figure>


<p>これで、リサイズやWibdowの移動ができるようになります。
あとは作成したい画面構成をイメージしながらGridを利用してレイアウトを区切っていきます。</p>

<p>まず、以下のようにしました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-03.png" alt="wpf-07-03" /></p>

<p>Gridを行単位で区切り、上部と下部を可変幅( <code>&lt;RowDefinition Height="auto"/&gt;</code> )、真ん中を領域いっぱいに利用(<code>&lt;RowDefinition Height="*"/&gt;</code>)するように宣言します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> &lt;Grid x:Name="PART_rootGrid"&gt;
</span><span class='line'>     &lt;Grid.RowDefinitions&gt;
</span><span class='line'>         &lt;RowDefinition Height="auto"/&gt;
</span><span class='line'>         &lt;RowDefinition Height="*"/&gt;
</span><span class='line'>         &lt;RowDefinition Height="auto"/&gt;
</span><span class='line'>     &lt;/Grid.RowDefinitions&gt;
</span><span class='line'>     &lt;Grid.ColumnDefinitions&gt;
</span><span class='line'>         &lt;ColumnDefinition Width="*"/&gt;
</span><span class='line'>     &lt;/Grid.ColumnDefinitions&gt;
</span><span class='line'>     
</span></code></pre></td></tr></table></div></figure>


<p>こうなると、もう普通のXamlで画面を開発するのと同じように、Style上でControlTemmplateの中身を記述していきます。</p>

<p>まず、Grid上部に対して詳細レイアウトをイメージし、その通りに新しくGridを配置します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-04.png" alt="wpf-07-04" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> &lt;!-- Grid.Row="0"として、親のグリッドの最初の行であることを宣言する --&gt;
</span><span class='line'> &lt;Grid Grid.Row="0" Height="100"&gt;
</span><span class='line'>     &lt;Grid.RowDefinitions&gt;
</span><span class='line'>         &lt;RowDefinition Height="auto"/&gt;
</span><span class='line'>         &lt;RowDefinition Height="auto"/&gt;
</span><span class='line'>         &lt;RowDefinition Height="*"/&gt;
</span><span class='line'>         &lt;RowDefinition Height="auto"/&gt;
</span><span class='line'>     &lt;/Grid.RowDefinitions&gt;
</span><span class='line'>     &lt;Grid.ColumnDefinitions&gt;
</span><span class='line'>         &lt;ColumnDefinition Width="auto"/&gt;
</span><span class='line'>         &lt;ColumnDefinition Width="auto"/&gt;
</span><span class='line'>         &lt;ColumnDefinition Width="*"/&gt;
</span><span class='line'>         &lt;ColumnDefinition Width="*"/&gt;
</span><span class='line'>     &lt;/Grid.ColumnDefinitions&gt;
</span></code></pre></td></tr></table></div></figure>


<p>次に0列目、4行をまたがっている領域を利用します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-05.png" alt="wpf-07-05" /></p>

<p>これは日本人にはなじみ深いExcelのセルをマージする要領ですね。
<code>Grid.Column="0" Grid.RowSpan="4"</code>　とすることで、そのようなマージされた領域を利用できます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Border Margin="10,0,5,0" Width="10" Grid.Column="0" Grid.RowSpan="4" Background="{DynamicResource AppBrand}" &gt;
</span><span class='line'>    &lt;Border.RenderTransform&gt;
</span><span class='line'>        &lt;TransformGroup&gt;
</span><span class='line'>            &lt;SkewTransform AngleY="50" /&gt;
</span><span class='line'>        &lt;/TransformGroup&gt;
</span><span class='line'>    &lt;/Border.RenderTransform&gt;
</span><span class='line'>&lt;/Border&gt;</span></code></pre></td></tr></table></div></figure>


<p>そこにBorder でブランドカラーの四角形を描画しています。
ただ、その四角形はWPFの強力な2Dグラフィック機能を利用して、少し角度をつけて描画しています。</p>

<p>ブランドに注目を集める事、アプリケーションのテーマカラーを確認できることを目的にしています。</p>

<p>次にブランドを表示する箇所です。同じようにグリッドのセルの座標を指定して領域を確保しますが、ここの文字はアプリケーションによって異なります。
そのため、バインドする必要があります。</p>

<p>このシリースはWindow.ContentにViewModelを、ContentTemplateSelectorを利用してViewを表示しています。</p>

<p>なので、このコンテンツにとって、バインドする際のプロパティまでのパスは、Content.(ViewModelのプロパティ名)とし、それを解決するための相対的な位置をバインディングに指定しています。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-06.png" alt="wpf-07-06" /></p>

<p>ViewModelの基底クラスにプロパティを用意することで、デフォルトで適用するもしくは開発者がViewModel側で任意に設定して表示することが可能となります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public string CompanyName
</span><span class='line'>{
</span><span class='line'>    get { return companyName; }
</span><span class='line'>    set { SetProperty(ref companyName, value); }
</span><span class='line'>}
</span><span class='line'>private string companyName = BizUtils.AppSettings("CompanyName", "");
</span></code></pre></td></tr></table></div></figure>


<p>後は同じようにデザインしていくのですが、今回は最小最大ボタンと設定ボタンという任意のボタンを配置しました。</p>

<p>最大最小のボタン デザイン面では、描画に<a href="http://www.itmedia.co.jp/help/tips/windows/w0288.html">Marlett</a> フォントを利用しています。
また、×ボタンはフォーカスを受け取ると、赤で強調表示されるようにしています。</p>

<p>設定マークは <a href="http://modernuiicons.com/">Alex Peattie</a>さんのフリーのXamlのジオメトリを利用しています。</p>

<p>ただ、レイアウトを用意するのは良いのですが、ここにクリックされた際の実装が必要になります。
そこで登場するのが、添付プロパティです。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-07.png" alt="wpf-07-07" /></p>

<p><code>local:WindowProxy.Command="Close"</code></p>

<p>WPFの組み込みコントロールクラスとは関係のない、別クラスで宣言した添付プロパティをセットし、処理を注入することができます。</p>

<p>VisualStudioのコードスニペット機能を利用してpropaと入力すると自動で添付プロパティが作成されます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-08.png" alt="wpf-07-08" /></p>

<p><img src="http://s-ueno.github.io/images/wpf-07-09.png" alt="wpf-07-09" /></p>

<p>今回はWindowの最小・最大　+　設定ボタンの押下時の処理を実装する添付プロパティクラスを用意しました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-07-10.png" alt="wpf-07-10" /></p>

<p>プロパティ値の変更時に処理が動くメソッドが定義できます。
ここで、ボタンに対してクリック時のイベントをバインドしています。</p>

<p>Styleで外観を刷新でき、処理も添付プロパティを利用して注入できるということは、たとえば、開発者はWPFの組込済みテキストボックスを配置、あとは提供されている任意の添付プロパティを選択すれば、自動で数値用テキストボックスや入力自動補完テキストボックスなどに差し替わることが可能となります。</p>

<p>ちなみに、Buttonクラスは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.buttonbase.command.aspx">Button.Command</a>プロパティが用意されていて、ここに組み込み済みのICommandを割り当てることもできます。
たとえば、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.systemcommands.aspx">SystemCommands</a>などです。</p>

<p>そうなのですが・・・・MSもどうしてICoomandをプロパティに持つという条件付の機能にしたのでしょうか？
それこそ添付プロパティとして、任意のルーティングイベントと紐付けられるように提供してくれれば、良かったのですが。</p>

<p>なぜかというと、前回のようにボタンから不要な機能をすべて削り落としていくと</p>

<p><img src="http://s-ueno.github.io/images/wpf-06-08.png" alt="wpf-06-08" /></p>

<p>もうテンプレートの中にはCommandプロパティを持つButtonの要素は存在しないのですよね。。。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Style x:Key="ModernButtonStyle" TargetType="{x:Type Button}" &gt;
</span><span class='line'>    &lt;Setter Property="Template"&gt;
</span><span class='line'>        &lt;Setter.Value&gt;
</span><span class='line'>            &lt;ControlTemplate TargetType="Button"&gt;
</span><span class='line'>                &lt;TextBlock Name="chrome" 
</span><span class='line'>                           HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" 
</span><span class='line'>                           VerticalAlignment="{TemplateBinding VerticalContentAlignment}"&gt;
</span><span class='line'>                    &lt;ContentPresenter /&gt;
</span><span class='line'>                &lt;/TextBlock&gt;
</span><span class='line'>                &lt;ControlTemplate.Triggers&gt;
</span><span class='line'>                    &lt;Trigger Property="IsMouseOver" Value="true"&gt;
</span><span class='line'>                        &lt;Setter TargetName="chrome" Property="TextBlock.TextDecorations" Value="Underline" /&gt;
</span><span class='line'>                    &lt;/Trigger&gt;
</span><span class='line'>                &lt;/ControlTemplate.Triggers&gt;
</span><span class='line'>            &lt;/ControlTemplate&gt;
</span><span class='line'>        &lt;/Setter.Value&gt;
</span></code></pre></td></tr></table></div></figure>


<p>TextBlockとContentPresenterしか要素がないので、Commandを設定しても動きません。
この制約は、添付プロパティの自由度と比べると見劣りしてしまいます。</p>

<p>ちなみに、今回はまだ設定ボタン押下時の処理を実装していません。
次回は、この設定ボタンを押下すると、アニメーションしながら設定画面が表示されるようにしたいと思います。</p>

<p>サンプル成果物はGit管理で。</p>

<p><a href="https://github.com/s-ueno/uENLab">@s-ueno/uENLab</a> on GitHub</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Buttonに学ぶテンプレートとスタイル - WPF Vol 05]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/11/wpf-06/"/>
    <updated>2014-11-11T23:58:00+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/11/wpf-06</id>
    <content type="html"><![CDATA[<p>Buttonの外観を通じて、テンプレートおよびスタイルについて紹介します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-06-01.png" alt="wpf-06-01" /></p>

<!-- more -->


<h2>Windows 7 スタイル</h2>

<p>WPFがこのお馴染みのスタイルを描画するためには、以下のような要件を適用しています。</p>

<ul>
<li>キーボードフォーカス(入力デバイスがキーボードがミソ。マウスじゃないよ)が入ると、ボタンの枠よりマージン2だけ小さい領域に指定した間隔の点線を描画</li>
<li>論理フォーカスが入ると、ButtonChromeクラスがゴニョゴニョして、ボタンの後ろ側にあるコンテンツの色がアクセント色になる</li>
<li>背景色は上から下に向かい、高さの半分からグラデーションで描画</li>
<li>マウスがボタンの上にくるとボタンの色がアクセント色になる</li>
<li>ボタンの上でマウスが押されている状態時に、ボタンの前景色を濃くする</li>
<li>ボタンの文字は、内部的にContentPresenterに文字を設定しているので、自動でTextBlock化して表示されている</li>
</ul>


<p>などなどキリがありませんが、これらの要件をXAMLのスタイル上で以下のように表現しています。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Style x:Key="ButtonFocusVisual"&gt;
</span><span class='line'>    &lt;Setter Property="Control.Template"&gt;
</span><span class='line'>        &lt;Setter.Value&gt;
</span><span class='line'>            &lt;ControlTemplate&gt;
</span><span class='line'>                &lt;Rectangle Margin="2" SnapsToDevicePixels="true" Stroke="{DynamicResource {x:Static SystemColors.ControlTextBrushKey}}" StrokeThickness="1" StrokeDashArray="1 2"/&gt;
</span><span class='line'>            &lt;/ControlTemplate&gt;
</span><span class='line'>        &lt;/Setter.Value&gt;
</span><span class='line'>    &lt;/Setter&gt;
</span><span class='line'>&lt;/Style&gt;
</span><span class='line'>&lt;LinearGradientBrush x:Key="ButtonNormalBackground" EndPoint="0,1" StartPoint="0,0"&gt;
</span><span class='line'>    &lt;GradientStop Color="#F3F3F3" Offset="0"/&gt;
</span><span class='line'>    &lt;GradientStop Color="#EBEBEB" Offset="0.5"/&gt;
</span><span class='line'>    &lt;GradientStop Color="#DDDDDD" Offset="0.5"/&gt;
</span><span class='line'>    &lt;GradientStop Color="#CDCDCD" Offset="1"/&gt;
</span><span class='line'>&lt;/LinearGradientBrush&gt;
</span><span class='line'>&lt;SolidColorBrush x:Key="ButtonNormalBorder" Color="#FF707070"/&gt;
</span><span class='line'>&lt;Style x:Key="AeroButtonStyle" TargetType="{x:Type Button}"&gt;
</span><span class='line'>    &lt;Setter Property="FocusVisualStyle" Value="{StaticResource ButtonFocusVisual}"/&gt;
</span><span class='line'>    &lt;Setter Property="Background" Value="{StaticResource ButtonNormalBackground}"/&gt;
</span><span class='line'>    &lt;Setter Property="BorderBrush" Value="{StaticResource ButtonNormalBorder}"/&gt;
</span><span class='line'>    &lt;Setter Property="BorderThickness" Value="1"/&gt;
</span><span class='line'>    &lt;Setter Property="Foreground" Value="{DynamicResource {x:Static SystemColors.ControlTextBrushKey}}"/&gt;
</span><span class='line'>    &lt;Setter Property="HorizontalContentAlignment" Value="Center"/&gt;
</span><span class='line'>    &lt;Setter Property="VerticalContentAlignment" Value="Center"/&gt;
</span><span class='line'>    &lt;Setter Property="Padding" Value="1"/&gt;
</span><span class='line'>    &lt;Setter Property="Template"&gt;
</span><span class='line'>        &lt;Setter.Value&gt;
</span><span class='line'>            &lt;ControlTemplate TargetType="{x:Type Button}"&gt;
</span><span class='line'>                &lt;Themes:ButtonChrome x:Name="Chrome" BorderBrush="{TemplateBinding BorderBrush}" Background="{TemplateBinding Background}" RenderMouseOver="{TemplateBinding IsMouseOver}" RenderPressed="{TemplateBinding IsPressed}" RenderDefaulted="{TemplateBinding IsDefaulted}" SnapsToDevicePixels="true"&gt;
</span><span class='line'>                    &lt;ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/&gt;
</span><span class='line'>                &lt;/Themes:ButtonChrome&gt;
</span><span class='line'>                &lt;ControlTemplate.Triggers&gt;
</span><span class='line'>                    &lt;Trigger Property="IsKeyboardFocused" Value="true"&gt;
</span><span class='line'>                        &lt;Setter Property="RenderDefaulted" TargetName="Chrome" Value="true"/&gt;
</span><span class='line'>                    &lt;/Trigger&gt;
</span><span class='line'>                    &lt;Trigger Property="ToggleButton.IsChecked" Value="true"&gt;
</span><span class='line'>                        &lt;Setter Property="RenderPressed" TargetName="Chrome" Value="true"/&gt;
</span><span class='line'>                    &lt;/Trigger&gt;
</span><span class='line'>                    &lt;Trigger Property="IsEnabled" Value="false"&gt;
</span><span class='line'>                        &lt;Setter Property="Foreground" Value="#ADADAD"/&gt;
</span><span class='line'>                    &lt;/Trigger&gt;
</span><span class='line'>                &lt;/ControlTemplate.Triggers&gt;
</span><span class='line'>            &lt;/ControlTemplate&gt;
</span><span class='line'>        &lt;/Setter.Value&gt;
</span><span class='line'>    &lt;/Setter&gt;
</span><span class='line'>&lt;/Style&gt;</span></code></pre></td></tr></table></div></figure>


<p>このStyleですが、VisualStudio上で以下のように右クリックで簡単に取得できます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-06-02.png" alt="wpf-06-02" /></p>

<p>XAML上に <code>&lt;Button Width="150" Height="50" Content="送信する" x:Name="SampleButton"/&gt;</code> と定義するだけで、内部的にはButton用スタイルが自動で適用されているわけです。
ボタン自体のスタイルは <code>&lt;Style x:Key="AeroButtonStyle" TargetType="{x:Type Button}"&gt;</code> から始まります。</p>

<p> <code>x:Key="AeroButtonStyle"</code> とキー指定している場合は、XAML上で明示的にキーを設定しないと適用されません。</p>

<p>キー指定せずに <code>&lt;Style TargetType="{x:Type Button}"&gt;</code> とStyle定義すると、全てのボタンのスタイルがこれから定義するStyleに自動で従うようになります。<br/>
また、 <code>&lt;Style TargetType="{x:Type Button}" BasedOn="{StaticResource {x:Type Button}}"&gt;</code> と、BasedOnを指定することで、元になる定義済みのスタイルを適用した上で任意のスタイルを上書きすることもできます。</p>

<p> <code>&lt;Setter Property="FocusVisualStyle" Value="{StaticResource ButtonFocusVisual}"/&gt;</code>
ですが、TargetTypeが Button で Property名が &ldquo;FocusVisualStyle&rdquo; つまり <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.frameworkelement.focusvisualstyle.aspx">Button.FocusVisualStyle</a> プロパティに対して、Value=で &ldquo;ButtonFocusVisual&rdquo; というキー名の値を設定していることを表します。</p>

<p>このキー名に一致するものは、以下のようになっています・</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Style x:Key="ButtonFocusVisual"&gt;
</span><span class='line'>    &lt;Setter Property="Control.Template"&gt;
</span><span class='line'>        &lt;Setter.Value&gt;
</span><span class='line'>            &lt;ControlTemplate&gt;
</span><span class='line'>                &lt;Rectangle Margin="2" SnapsToDevicePixels="true" Stroke="{DynamicResource {x:Static SystemColors.ControlTextBrushKey}}" StrokeThickness="1" StrokeDashArray="1 2"/&gt;
</span><span class='line'>            &lt;/ControlTemplate&gt;
</span><span class='line'>        &lt;/Setter.Value&gt;
</span><span class='line'>    &lt;/Setter&gt;
</span><span class='line'>&lt;/Style&gt;</span></code></pre></td></tr></table></div></figure>


<p>Margin=&ldquo;2&rdquo; で StrokeThickness=&ldquo;1&rdquo; StrokeDashArray=&ldquo;1 2&#8221;のRectangleを描画していますね。<br/>
確かにTabでキーボードフォーカスを入れると、ちょっと小さな枠に点線で四角が描画されていませんか？</p>

<p><img src="http://s-ueno.github.io/images/wpf-06-03.png" alt="wpf-06-03" /></p>

<p>WPFが標準で提供する組込みコントロールも、最小限の部品（LabelやTextBlock、Rectangle）を組み合わせて構成されていることがわかります。
なので、これら最小限の部品に対しては、デフォルトでスタイルが適用されるようなことをやってはなりません。</p>

<p> <code>&lt;Style TargetType="{x:Type TextBlock}"&gt;</code> とかすると、TextBlockはいたるところで利用されているので画面がまともに描画されなくなります。</p>

<p>といっても、テキストブロック用のStyleを用意したい場合には <code>&lt;Style x:Key="MyTextBlock" TargetType="{x:Type TextBlock}"&gt;</code> のようにキーを明示的に宣言して、他のコントロールに影響がでないようにします。</p>

<p>次に <code>&lt;Setter Property="</code> とプロパティ値をカスタマイズしていきますが、この際にスタイルをダイナミックに適用することもできます。</p>

<p> <code>&lt;Setter Property="Background" Value="{DynamicResource MyBackgroundBrush}"/&gt;</code></p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/ms748942.aspx">DynamicResource</a>ですが、これは要素が実際にテンプレートを必要とする（描画）段階で、キー名で検索して適用します。
StaticResourceが定数としたら、DynamicResourceは書き換え可能な変数というところでしょうか。</p>

<p>アプリケーションはそのブランドイメージに見合う色などがあります。
このブログも今は白とブルーを基調としたイメージカラーになっています。
このようなイメージカラーをたとえば、カラーピッカーなどを利用してアプリケーションの実行中にダイナミックに変更することが可能になります。</p>

<h2>テンプレート</h2>

<p>Xamlを利用して、様々なStyleを作成していく中で、 <code>&lt;Setter Property="Template"&gt;</code> については、特別な意味があります。
<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.control.template.aspx">Button.Template</a> プロパティは、このボタンの外観に関する全てを新しく書き換えることを意味します。</p>

<p>Windows7のAeroスタイル例を整理しながら説明します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Setter Property="Template"&gt;
</span><span class='line'>    &lt;Setter.Value&gt;
</span><span class='line'>        &lt;ControlTemplate TargetType="{x:Type Button}"&gt;
</span><span class='line'>            &lt;Themes:ButtonChrome x:Name="Chrome" BorderBrush="{TemplateBinding BorderBrush}" Background="{TemplateBinding Background}" RenderMouseOver="{TemplateBinding IsMouseOver}" RenderPressed="{TemplateBinding IsPressed}" RenderDefaulted="{TemplateBinding IsDefaulted}" SnapsToDevicePixels="true"&gt;
</span><span class='line'>                &lt;ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" Margin="{TemplateBinding Padding}" RecognizesAccessKey="True" SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/&gt;
</span><span class='line'>            &lt;/Themes:ButtonChrome&gt;
</span><span class='line'>        &lt;/ControlTemplate&gt;
</span><span class='line'>    &lt;/Setter.Value&gt;
</span><span class='line'>&lt;/Setter&gt;</span></code></pre></td></tr></table></div></figure>


<p><code>&lt;ControlTemplate TargetType="{x:Type Button}"&gt;</code> として、Buttonの外観を再定義しています。</p>

<p>その中身は <code>&lt;Themes:ButtonChrome ・・・</code> として、<a href="http://msdn.microsoft.com/ja-jp/library/microsoft.windows.themes.buttonchrome.aspx">Microsoft.Windows.Themes.ButtonChrome</a> クラスを指定しています。
仮にココにCheckBoxを指定した場合は、開発者はButtonをXamlに定義しているにもかかわらず、実行してみると画面上にはチェックボックスが表示されることになります。これがテンプレートです。</p>

<p>各種プロパティに設定している<a href="http://msdn.microsoft.com/ja-jp/library/ms742882.aspx">TemplateBinding</a>は、別のコントロール プロパティ値を参照するバインディング機能になります。
ここでは、ButtonChrome.BorderBrushは、ControlTemplateで定義されているButton(つまりもともとのコントロール)のBorderBrush値を参照するように設定されています。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/ms742882.aspx">TemplateBinding</a> はより具体的で柔軟な設定を可能とし、例えば2個上の親コンテンツのプロパティ値や、指定した親の型が見つかればその値を利用するなど、カスタム コントロールを作成するレベルでは、とても重宝するバインディング機能の一つです。</p>

<p>WPFはバインディングとテンプレートが肝要と紹介する所以です。</p>

<p><code>&lt;ContentPresenter ・・・</code> は Botton.Contentプロパティに設定した&#8221;送信する&#8221;という表示文字列が、ContentPresenterに設定された結果、前に説明した通りTextBlockとして画面に表示されることになります。</p>

<p>WPFのデバック機能で、ビジュアライザーというものがあります。
これを通して、外観を確認すると、なるほどとなります。</p>

<p>サンプルボタン</p>

<p><img src="http://s-ueno.github.io/images/wpf-06-04.png" alt="wpf-06-04" /></p>

<p>そのテンプレートの最終的なContentPresenter</p>

<p><img src="http://s-ueno.github.io/images/wpf-06-05.png" alt="wpf-06-05" /></p>

<p>次に、先ほどは省略しましたが ControlTemplate に、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.controltemplate.triggers.aspx">ControlTemplate.Triggers</a> プロパティ値を設定していたと思います。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;ControlTemplate.Triggers&gt;
</span><span class='line'>    &lt;Trigger Property="IsKeyboardFocused" Value="true"&gt;
</span><span class='line'>        &lt;Setter Property="RenderDefaulted" TargetName="Chrome" Value="true"/&gt;
</span><span class='line'>    &lt;/Trigger&gt;
</span><span class='line'>    &lt;Trigger Property="ToggleButton.IsChecked" Value="true"&gt;
</span><span class='line'>        &lt;Setter Property="RenderPressed" TargetName="Chrome" Value="true"/&gt;
</span><span class='line'>    &lt;/Trigger&gt;
</span><span class='line'>    &lt;Trigger Property="IsEnabled" Value="false"&gt;
</span><span class='line'>        &lt;Setter Property="Foreground" Value="#ADADAD"/&gt;
</span><span class='line'>    &lt;/Trigger&gt;
</span><span class='line'>&lt;/ControlTemplate.Triggers&gt;</span></code></pre></td></tr></table></div></figure>


<p>これがXAMLが単なる<a href="http://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E8%A8%98%E8%BF%B0%E8%A8%80%E8%AA%9E">データ記述言語</a>よりも優れていて、なんらかのイベント トリガーをキーに動的にプロパティ値を変更することができる技術になります。</p>

<p>キーボードフォーカスを受け取ったときや、非活性時にはそれに見合ったスタイルを動的に適用することができます。</p>

<p>こういった様々なXAML上の技術が適用されてWindows7のAeroスタイルが適用されていますが、ここで考えたいのが</p>

<blockquote><p>“What is the difference between art and design?”（デザインとアートの違いとは何か？）</p>

<p>”Design solves a problem, art is expression”（デザインとは問題解決であり、アートとは自己表現である。）</p>

<p>Why?をBecauseで説明出来なければ、それは明らかにデザインではない</p></blockquote>

<p>です。</p>

<p>これを素で開発するとした場合は、開発者には高い技術力を求め、OSもこれを描画するための高いコストを支払います。
果たして、これに対して Because を説明できるでしょうか？</p>

<p>そうした結果が、Windows8 Styleや Flat Ftyleにつながりますが、果たしてまだ最適化はできないものでしょうか？</p>

<h2>Windows8 Style</h2>

<p><img src="http://s-ueno.github.io/images/wpf-06-06.png" alt="wpf-06-06" /></p>

<p>Flat Styleはボタンを押下すると、ブランド カラー が表示されています。<br/>
どちらも、無駄なグラデーションなどはなくなりました。</p>

<p>Windows 8 で、同じようにXaml上で右クリック-テンプレートの編集から、適用されているXAMLのスタイルが簡単にコピーできます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Style x:Key="FlatButtonStyle" TargetType="{x:Type Button}"&gt;
</span><span class='line'>
</span><span class='line'>&lt;!-- アプリケーションで統一的なフォント、サイズなどをダイナミックに適用 --&gt;
</span><span class='line'>&lt;Setter Property="Foreground"                   Value="{DynamicResource AppForeground}"/&gt;
</span><span class='line'>&lt;Setter Property="FontFamily"                   Value="{DynamicResource AppFont}"/&gt;
</span><span class='line'>&lt;Setter Property="FontSize"                     Value="{DynamicResource AppFontSize}"/&gt;
</span><span class='line'>
</span><span class='line'>&lt;!-- ボタン特有のスタイル --&gt;
</span><span class='line'>&lt;Setter Property="Background"                   Value="{DynamicResource ButtonBackground}"/&gt;
</span><span class='line'>&lt;Setter Property="BorderBrush"                  Value="{DynamicResource ButtonBorder}"/&gt;
</span><span class='line'>&lt;Setter Property="FocusVisualStyle"             Value="{x:Null}"/&gt;
</span><span class='line'>&lt;Setter Property="BorderThickness"              Value="1,1,1,1"/&gt;
</span><span class='line'>&lt;Setter Property="HorizontalContentAlignment"   Value="Center"/&gt;
</span><span class='line'>&lt;Setter Property="VerticalContentAlignment"     Value="Center"/&gt;
</span><span class='line'>&lt;Setter Property="Template"&gt;
</span><span class='line'>    &lt;Setter.Value&gt;
</span><span class='line'>        &lt;ControlTemplate TargetType="{x:Type Button}"&gt;
</span><span class='line'>            &lt;Border x:Name="border" 
</span><span class='line'>                    BorderBrush="{TemplateBinding BorderBrush}" 
</span><span class='line'>                    BorderThickness="{TemplateBinding BorderThickness}" 
</span><span class='line'>                    Background="{TemplateBinding Background}" 
</span><span class='line'>                    SnapsToDevicePixels="True"&gt;
</span><span class='line'>                &lt;ContentPresenter x:Name="contentPresenter" 
</span><span class='line'>                                  ContentTemplate="{TemplateBinding ContentTemplate}" 
</span><span class='line'>                                  Content="{TemplateBinding Content}" 
</span><span class='line'>                                  ContentStringFormat="{TemplateBinding ContentStringFormat}" 
</span><span class='line'>                                  Focusable="False" 
</span><span class='line'>                                  HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" 
</span><span class='line'>                                  Margin="{TemplateBinding Padding}" 
</span><span class='line'>                                  RecognizesAccessKey="True" 
</span><span class='line'>                                  SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" 
</span><span class='line'>                                  VerticalAlignment="{TemplateBinding VerticalContentAlignment}"/&gt;
</span><span class='line'>            &lt;/Border&gt;
</span><span class='line'>            &lt;ControlTemplate.Triggers&gt;
</span><span class='line'>                &lt;Trigger Property="IsEnabled" Value="false"&gt;
</span><span class='line'>                    &lt;Setter Property="Foreground" Value="{DynamicResource AppForegroundDisabled}"/&gt;
</span><span class='line'>                    &lt;Setter Property="Background" Value="{DynamicResource AppDisabled}"/&gt;
</span><span class='line'>                &lt;/Trigger&gt;
</span><span class='line'>                &lt;Trigger Property="IsMouseOver" Value="True"&gt;
</span><span class='line'>                    &lt;Setter Property="Background" Value="{DynamicResource ButtonBackgroundHover}" /&gt;
</span><span class='line'>                    &lt;Setter Property="BorderBrush" Value="{DynamicResource ButtonBorderHover}"/&gt;
</span><span class='line'>                    &lt;Setter Property="Foreground" Value="{DynamicResource ButtonTextHover}"/&gt;
</span><span class='line'>                &lt;/Trigger&gt;
</span><span class='line'>                &lt;Trigger Property="IsPressed" Value="True"&gt;
</span><span class='line'>                    &lt;Setter Property="Background" Value="{DynamicResource ButtonBackgroundPressed}" /&gt;
</span><span class='line'>                    &lt;Setter Property="BorderBrush" Value="{DynamicResource ButtonBorderPressed}"/&gt;
</span><span class='line'>                    &lt;Setter Property="Foreground" Value="{DynamicResource ButtonTextPressed}"/&gt;
</span><span class='line'>                &lt;/Trigger&gt;
</span><span class='line'>                &lt;Trigger Property="IsFocused" Value="true"&gt;
</span><span class='line'>                    &lt;Setter TargetName="border" Property="BorderBrush" Value="{DynamicResource AppBrand}" /&gt;
</span><span class='line'>                &lt;/Trigger&gt;
</span><span class='line'>            &lt;/ControlTemplate.Triggers&gt;
</span><span class='line'>        &lt;/ControlTemplate&gt;
</span><span class='line'>    &lt;/Setter.Value&gt;
</span><span class='line'>&lt;/Setter&gt;
</span><span class='line'>&lt;/Style&gt;</span></code></pre></td></tr></table></div></figure>


<p>Wibndows 7 のAeroスタイルよりもまだ描画コストは減りましたが、あんまり変わりませんね。
もっと、最適化できないか？削れないか？本当にそれは必要か？と考えた際にたどり着くのがModern Styleになります。</p>

<h2>Modern Style</h2>

<p>もはやボタン枠すらもありませんが、確かにユーザーはそれを押下できるコンテンツと認識でき、何が起こるかを理解できます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-06-07.png" alt="wpf-06-07" /></p>

<p>こうなると、XAML上のスタイルも簡単で、OSもこれを描画するためにコストはかけません。<br/>
かといって、ユーザーがこれを退屈なコンテンツと認識するかといえば、とてもモダンな雰囲気を受けます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Style x:Key="ModernButtonStyle" TargetType="{x:Type Button}" &gt;
</span><span class='line'>&lt;Setter Property="Foreground"                   Value="{DynamicResource AppBrand}" /&gt;
</span><span class='line'>&lt;Setter Property="FontFamily"                   Value="{DynamicResource AppFont}"/&gt;
</span><span class='line'>&lt;Setter Property="FontSize"                     Value="{DynamicResource AppFontSize}"/&gt;
</span><span class='line'>
</span><span class='line'>&lt;Setter Property="FocusVisualStyle"             Value="{x:Null}"/&gt;
</span><span class='line'>&lt;Setter Property="HorizontalContentAlignment"   Value="Center"/&gt;
</span><span class='line'>&lt;Setter Property="VerticalContentAlignment"     Value="Center"/&gt;
</span><span class='line'>&lt;Setter Property="Focusable"                    Value="False" /&gt;
</span><span class='line'>&lt;Setter Property="Template"&gt;
</span><span class='line'>    &lt;Setter.Value&gt;
</span><span class='line'>        &lt;ControlTemplate TargetType="Button"&gt;
</span><span class='line'>            &lt;TextBlock Name="chrome" 
</span><span class='line'>                       HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" 
</span><span class='line'>                       VerticalAlignment="{TemplateBinding VerticalContentAlignment}"&gt;
</span><span class='line'>                &lt;ContentPresenter /&gt;
</span><span class='line'>            &lt;/TextBlock&gt;                
</span><span class='line'>            &lt;ControlTemplate.Triggers&gt;
</span><span class='line'>                &lt;Trigger Property="IsMouseOver" Value="true"&gt;
</span><span class='line'>                    &lt;Setter TargetName="chrome" Property="TextBlock.TextDecorations" Value="Underline" /&gt;
</span><span class='line'>                &lt;/Trigger&gt;
</span><span class='line'>            &lt;/ControlTemplate.Triggers&gt;
</span><span class='line'>        &lt;/ControlTemplate&gt;
</span><span class='line'>    &lt;/Setter.Value&gt;
</span><span class='line'>&lt;/Setter&gt;
</span><span class='line'>&lt;Style.Triggers&gt;
</span><span class='line'>    &lt;Trigger Property="IsEnabled" Value="false"&gt;
</span><span class='line'>        &lt;Setter Property="Foreground" Value="{DynamicResource AppForegroundDisabled}"/&gt;
</span><span class='line'>    &lt;/Trigger&gt;
</span><span class='line'>&lt;/Style.Triggers&gt;
</span><span class='line'>&lt;/Style&gt;
</span></code></pre></td></tr></table></div></figure>


<p>もはやスタイルは必要最低限で、しかしマウスが乗るとそれが実行可能なコンテンツであることを即座に理解できます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-06-08.png" alt="wpf-06-08" /></p>

<p>ブランドカラーをカスタマイズもできます。
しかも、これはアプリケーション ポリシーのようなもので、開発者はただ単にXaml上でButtonと定義しただけにもかかわらず、自動的にこのスタイルが適用されることになります。</p>

<p>LOB開発が、モダンで先進的なWebデザインに一矢報いることも夢ではありません。</p>

<p>いつものごとく、サンプル成果物はGit管理で。</p>

<p><a href="https://github.com/s-ueno/uENLab">@s-ueno/uENLab</a> on GitHub</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What is the difference between art and design?]]></title>
    <link href="http://s-ueno.github.io/blog/2014/11/11/wpf-05/"/>
    <updated>2014-11-11T01:09:00+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/11/11/wpf-05</id>
    <content type="html"><![CDATA[<p>WPFでテンプレートやスタイルに入る前に、ぜひ<a href="http://blog.btrax.com/jp/2012/03/17/what-i-learned-from-design-education/">紹介したい記事</a>があります。</p>

<p>“What is the difference between art and design?”（デザインとアートの違いとは何か？）</p>

<!-- more -->


<blockquote><p>この質問は、米国で初級デザインクラスを受ける学生達が、教授達から頻繁に投げかけられる問いの1つです。</p>

<p>デザインを習い始めた学生の多くは、デザインとアートを混同しているためです。デザインとアートの間には、決定的な違いあります。</p></blockquote>

<p>これに対する回答は</p>

<blockquote><p>”Design solves a problem, art is expression”（デザインとは問題解決であり、アートとは自己表現である。）</p></blockquote>

<p>とあります。</p>

<blockquote><p>Why?をBecauseで説明出来なければ、それは明らかにデザインではないということなのです。何となく、個人的に好きだから、感覚で、といった理由を述べた時点でそれはアート（自己表現）であり、デザイン（問題解決）ではありません。それは言い換えると、問題と向き合い、それを解決する中で生まれたモノのみがデザインであるということでもあります。</p></blockquote>

<p>昔から今に至るまで日本の職人さんたちによる ものづくりの世界では当たり前のことかもしれません。</p>

<p>たとえば、鉛筆の形状が正六角形なのはどうして？という問いに</p>

<ul>
<li>鉛筆の先は3本の指をほぼ等間隔にして持つため、断面が3の倍数角形や円以外だと、指が稜に当たってしまう。</li>
<li>正六角形の鉛筆は、同じ量の木材から多く作ることができる。円はそれに次ぐ（ただし、3の倍数に限らなければ、正方形が最も効率がいい）。</li>
<li>円形の鉛筆は、傾いた面に置くと転がってしまう。</li>
</ul>


<p>と職人さん＠wikiは答えてくれるのでしょう。</p>

<p>ユーザーの体感する利便性　+　ビジネス上のメリットが見事に融合しています。</p>

<p>現在でも車のインテリア、携帯端末、ゲームのコントローラーなど、サイズや配置をユーザー利便性+コストカットを意識してデザインを突き詰めていると思います。</p>

<p>全てに意味があり極限まで余計なものをそぎ落とし、それでいて魅力のある外観です。</p>

<p>初めて乗る車であっても、エアコンのつけ方が直観でわからなくて説明書を読むようなことはまずないでしょう。</p>

<p>UX（ユーザーが体感する利便性）などよく聞きますが、LOB開発の画面レイアウトや配置に
果たしてどれだけの人が“デザイン”を考えているでしょう？</p>

<p>たとえば、ボタンについて考えてみます。<br/>
コレです。</p>

<p><img src="http://s-ueno.github.io/images/wpf-05-01.png" alt="wpf-05-01" /></p>

<p>Windows7まで採用されているAeroスタイルが適用されています。</p>

<ul>
<li>丸みを帯びた枠線</li>
<li>色はグラデーションがかかり</li>
<li>ボタンを押下すると凹み、</li>
<li>マウスを上げるともとに戻る</li>
</ul>


<p>現実世界のボタンに似せたスタイルになっています。</p>

<p>果たしてこれに、ユーザーが体験する利便性や楽しみ、ビジネス上のメリットを説明するとなるとどうでしょう。</p>

<p>マイクロソフトは同じアプリをWindows8で実行すると、こう回答してくれます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-05-02.png" alt="wpf-05-02" /></p>

<p>もっと言うと、Windowsストアアプリをダウンロードすると、もうこのようなボタンでさえ、見つけることは難しいでしょう。</p>

<p>昔はスキューモフィズムといわれる、現実世界にデザインを似せることが良いとされてきました。</p>

<p>Windows8以降はフラットデザイン、Modernスタイルなどと言われますが、これは当初ロンドンの地下鉄標識を基調として発展したとあります。</p>

<p>そこから、極限まで無駄をそぎ落とし、それでいてモダンなスタイルを表現してくれるデザインがフラットデザインになります。</p>

<p>たとえば、乗換ストアアプリを利用してみると</p>

<p><img src="http://s-ueno.github.io/images/wpf-05-03.png" alt="wpf-05-03" /></p>

<p>不要なラベル枠線やグラデーションなどありません。<br/>
とても直観的に入力できます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-05-04.png" alt="wpf-05-04" /></p>

<p>このアプリに利用マニュアルは必要ないでしょう。</p>

<p>Windows8が出て、Apple、Amazon（Gitはとても素晴らしい）など大手でフラットデザインではないものはないと思います。</p>

<p>ところがどうして、最もUXを考えなければならないLOB開発の現場では、まだこれがスタンダードだとは言えないと思います。</p>

<p>デザインとアートを混同していることも多いでしょう。</p>

<p>ただし、私たちにはXAMLという強力な道具があります。<br/>
それに対して、開発者がWPFテクノロジーを意識せずとも適用できるのがスタイルでありテンプレートです。</p>

<p>こういった背景を踏まえた上で、次回以降にスタイルとテンプレート紹介したいと思います。</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WPF ViewModelでLOB開発 Vol 04 - コンポジットWPF　おまけでMEF]]></title>
    <link href="http://s-ueno.github.io/blog/2014/10/31/wpf-04/"/>
    <updated>2014-10-31T17:50:00+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/10/31/wpf-04</id>
    <content type="html"><![CDATA[<p>サンプル成果物はGit管理するようにしました。</p>

<p><a href="https://github.com/s-ueno/uENLab">@s-ueno/uENLab</a> on GitHub</p>

<p>今回は、以前からお話ししていましたコンポジットWPFの片鱗と、おまけで <a href="http://msdn.microsoft.com/ja-jp/library/dd460648.aspx">MEF</a> という.Net Frameworkが提供する <a href="http://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E3%81%AE%E6%B3%A8%E5%85%A5">DI</a> について紹介します。</p>

<!-- more -->


<p>コンポジット アプリケーション は動いている画面を見ると1画面なのですが、開発時には複数のコントロールを組み合わせて動くような仕組みになります。
Windows Formの頃はユーザーコントロールとして作成していましたが、ここで利用しているコンテンツ（View/ViewModelセット）には区別はありません。</p>

<p>サンプルを起動すると以下の画面が起動します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-04-01.png" alt="wpf-04-01" /></p>

<p>フレキシブル レイアウトなので、画面を大きくすれば自動でリサイズします。</p>

<p>ShellViewクラスはTabControlを持ち、TabItemとしてアサインしているのものはVol04Viewクラスです。</p>

<p>Vol04Viewクラスには、前回作成した必須入力ルールをテキストボックスに適用しており、ボタン押下のタイミングで検証エラーを検知してアプリケーション例外（業務例外ともいい、致命的な例外とは区別します）をスローします。
ここにMEFの機能を利用して、例外が業務例外ならばその内容を警告メッセージボックスとして表示する仕組みを注入しています。</p>

<ul>
<li>コンポジット構成</li>
<li>MEFによる業務固有処理の抽入</li>
</ul>


<p>それぞれについて紹介します。</p>

<h2>コンポジット構成</h2>

<p>MVVMデザイン パターンでは、どのデータ（ViewModel）をどういう外観で描画する（View）というセットをコンテンツとして取り扱います。</p>

<p>Window が持つ唯一のContentプロパティには、ContentPresenterがあり、コンテンツを表現する箱として機能します。</p>

<p>ContentにViewModelをセットし、このコンテンツの外観を決定するDataTemplateSelectorを利用して、ViewModelの属性として表現したViewを適用しています。</p>

<p>この仕組みはどのようなコンテンツでも適用できます。今回利用した<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.tabcontrol.aspx">TabControl</a>を確認してみます。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.tabcontrol.aspx">TabControl</a>は<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.selector.aspx">Selector</a>,<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.aspx">ItemsControl</a>とベースクラスに持ちます。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.aspx">ItemsControl</a>は複数のコンテンツを持つベースとなるクラスです。<br/>
<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.selector.aspx">Selector</a>は、その複数コンテンツは選択および非選択ができる機能のベースクラスです。<br/>
<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.tabcontrol.aspx">TabControl</a>はそれらの機能を持ち、各コンテンツにセットでHeaderコンテンツを持つクラスになります。</p>

<p>個人的には<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.aspx">ItemsControl</a>、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.selector.aspx">Selector</a>までは優秀なのですが、これを使って作った<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.tabcontrol.aspx">TabControl</a>はちょっと残念な気がしています。
もっと利便性が高い、複数コンテンツを選択可能なコントロールを作成するのはとても簡単なので、シリーズの中で紹介したいと思います。</p>

<p>さておき、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.aspx">ItemsControl</a>などの複数のコンテンツを持つクラスは、大きく二つの機能を利用します。</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.itemssource.aspx">ItemsControl.ItemsSource</a> プロパティ</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.itemscontrol.itemtemplateselector.aspx">ItemsControl.ItemTemplateSelector</a> プロパティ</li>
</ul>


<p>ItemsSourceは、その通り複数のデータを設定するプロパティです。
ItemTemplateSelectorは、DataTemplateSelectorと同じで、それぞれのデータはどのような外観なのかを選択するための機能になります。</p>

<p>WindowではContentは一つでしたが、ItemsSourceは複数のコンテンツをセットします。
このセットする際に利便性が高いものが <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.listcollectionview.aspx">ListCollectionView</a> クラスです。</p>

<p>このクラスは外観を持たないコレクションクラスであり、ViewとViewModelに分離したデザインではViewModel側で利用するクラスになります。</p>

<p>ただ、このコレクションにバインドしている外観がもし選択および非選択ができる機能を有するのであれば、そこに指示するMoveCurrentToメソッドなどを持つ、かゆいところに手が届くクラスになります。
このクラスでフィルタリングして10件を2件とした場合なども、外観にも反映され10タブを2タブにしたりすることができます。</p>

<p>ShellView/ShellViewModel クラスはこのコレクションを管理する機能になります。
コンテンツの実体はVol04View/Vol04ViewModelクラスです。</p>

<p>コンポジット アプリケーションではオブジェクト指向を意識しなくても、柔軟なクラス分割を可能とし、それによって同時開発による生産性の向上や保守性の向上、またパフォーマンス向上も期待できます。</p>

<p>業務要件で複雑なTab機能を有する画面を1つのクラスで作成すると、1万STEPを超えるような複雑怪奇なクラスを作りかねないのですが、このような仕組みではどのようなリッチな画面構成でも、シンプルに作成できます。</p>

<h2>MEF</h2>

<p>DIを利用したことがなければピンとこないかもしれません。<br/>
要はインターフェイスに対して、後付けでインスタンスを割り当てることができる機能になります。</p>

<p>LOB開発では様々な横断的関心事が出てきますが、その中には業務要件固有であるものも少なくありません。</p>

<p>業務固有要件なので、システム毎に開発者が用意する機能であり、且つ横断的な関心事であればそれをあちこちでサービス呼び出しするようなことを適用したくない場合に、有効に活用できます。</p>

<p>MEFを利用するためには参照設定で「System.ComponentModel.Composition」を追加する必要があります。</p>

<p>サンプルのSimpleAppプロジェクトにはExceptionPolicyクラスがあります。
このクラスはIExceptionPolicyインターフェイスを実装しています。</p>

<p>このIExceptionPolicyインターフェイスを宣言し、利用しているプロジェクトはuENプロジェクトですが、実際にこのインターフェイスを実装している箇所はありません。
仮にこのインターフェイスに実体が与えられていれば、それを動かすというコーディングのみがあります。</p>

<p>MEFが提供するImport属性を宣言しているので、仮にMEF機能が働けばここにインスタンスがインポートされるイメージになります。
開発者は、このインターフェイスを実装するクラスに対してExport属性を付与することで、そのクラスが適用される仕組みになります。</p>

<p>MEFを利用するにもおまじないコードは必要なのですが、今回はRepositoryクラスを用意しました。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  public static class Repository
</span><span class='line'>    {
</span><span class='line'>        private static readonly List&lt;ComposablePartCatalog&gt; catalogList = new List&lt;ComposablePartCatalog&gt;();
</span><span class='line'>        static Repository()
</span><span class='line'>        {
</span><span class='line'>            var assemblies = ConfigurationManager.GetSection("Repository.AssemblyCatalog") as NameValueCollection;
</span><span class='line'>            foreach (var each in assemblies.AllKeys)
</span><span class='line'>            {
</span><span class='line'>                var assembly = LoadAssembly(each);
</span><span class='line'>                if (assembly != null)
</span><span class='line'>                {
</span><span class='line'>                    catalogList.Add(new AssemblyCatalog(assembly));
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            var types = ConfigurationManager.GetSection("Repository.TypeCatalog") as NameValueCollection;
</span><span class='line'>            foreach (var each in types.AllKeys)
</span><span class='line'>            {
</span><span class='line'>                var type = LoadType(each);
</span><span class='line'>                if (type != null)
</span><span class='line'>                {
</span><span class='line'>                    catalogList.Add(new TypeCatalog(type));
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            var catalog = new AggregateCatalog();
</span><span class='line'>            foreach (var each in catalogList)
</span><span class='line'>            {
</span><span class='line'>                catalog.Catalogs.Add(each);
</span><span class='line'>            }
</span><span class='line'>            container = new CompositionContainer(catalog);
</span><span class='line'>        }
</span><span class='line'>        private static Assembly LoadAssembly(string s)
</span><span class='line'>        {
</span><span class='line'>            Assembly assembly = null;
</span><span class='line'>            try
</span><span class='line'>            {
</span><span class='line'>                assembly = Assembly.Load(s);
</span><span class='line'>            }
</span><span class='line'>            catch
</span><span class='line'>            {
</span><span class='line'>            }
</span><span class='line'>            return assembly;
</span><span class='line'>        }
</span><span class='line'>        private static Type LoadType(string s)
</span><span class='line'>        {
</span><span class='line'>            Type type = null;
</span><span class='line'>            try
</span><span class='line'>            {
</span><span class='line'>                type = Type.GetType(s);
</span><span class='line'>            }
</span><span class='line'>            catch
</span><span class='line'>            {
</span><span class='line'>            }
</span><span class='line'>            return type;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        private static CompositionContainer container;
</span><span class='line'>        public static void Compose(this object obj)
</span><span class='line'>        {
</span><span class='line'>            container.ComposeParts(obj);
</span><span class='line'>        }
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>


<p>このリポジトリが構成ファイルから読み込むべき対象を抽出して実体化可能な状態にセットします。
利用する際には、Import属性を持つクラスのコンストラクタでCompose拡張メソッドを呼び出すことで、そのインターフェイスに自動でインスタンスが割り当てられる仕組みになります。</p>

<p>以下のように利用しています。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class ActionEventPolicyAttribute : Attribute, IRoutedEventPolicy
</span><span class='line'>{
</span><span class='line'>    public ActionEventPolicyAttribute()
</span><span class='line'>    {
</span><span class='line'>        this.Compose();
</span><span class='line'>    }
</span><span class='line'>    [Import(typeof(IExceptionPolicy))]
</span><span class='line'>    public IExceptionPolicy ExceptionPolicy { get; set; }
</span><span class='line'>   </span></code></pre></td></tr></table></div></figure>


<p>アプリケーション構成ファイル(app.config)ですが、configSectionsを利用することで、任意のセクションを追加することが可能になります。
これはmachin.configでも利用されているセクションです。</p>

<p>ここに二つのレベルで依存性を注入できるようにしています。</p>

<ul>
<li>アセンブリの中にあるExport属性の全てをMEFのカタログに登録する</li>
<li>アセンブリの中でも特定のクラスのみをMEFのカタログに登録する</li>
</ul>


<p>これによって、柔軟で且つソースコードの変更をかけずに機能を差し替えることが可能となります。</p>

<p>app.config</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="utf-8"?&gt;
</span><span class='line'>&lt;configuration&gt;
</span><span class='line'>  &lt;configSections&gt;
</span><span class='line'>    &lt;section name="Repository.AssemblyCatalog" type="System.Configuration.NameValueSectionHandler" /&gt;
</span><span class='line'>    &lt;section name="Repository.TypeCatalog" type="System.Configuration.NameValueSectionHandler" /&gt;
</span><span class='line'>  &lt;/configSections&gt;
</span><span class='line'>  &lt;Repository.AssemblyCatalog&gt;
</span><span class='line'>    &lt;add key="uEN" value="" /&gt;
</span><span class='line'>    &lt;add key="SimpleApp" value="" /&gt;
</span><span class='line'>  &lt;/Repository.AssemblyCatalog&gt;
</span><span class='line'>
</span><span class='line'>  &lt;Repository.TypeCatalog&gt;
</span><span class='line'>  &lt;/Repository.TypeCatalog&gt;</span></code></pre></td></tr></table></div></figure>


<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WPF ViewModelでLOB開発 Vol 03 - バインディング]]></title>
    <link href="http://s-ueno.github.io/blog/2014/10/08/wpf-03/"/>
    <updated>2014-10-08T12:00:00+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/10/08/wpf-03</id>
    <content type="html"><![CDATA[<p>これまでは必要最低限の予備学習でしたが、本質に切り込んで <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.aspx">バインディング</a> について紹介します。<br/>
WPFの肝要は バインディングとテンプレートだと言えるくらい重要です。</p>

<p>今回はDateTimeを表示するだけの簡単なサンプルですが、WPF プロパティ システム の仕組みを覗いてみたいと思います。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-07.png" alt="wpf-03-07" /></p>

<!-- more -->


<p>前回までと同じですが、今度はViewModelのプロパティがDateTime型となっており、バインディング時に一つだけ表示書式が適用されています。</p>

<h2>ViewModel</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[VisualElements(typeof(BizViewModelName1View))]
</span><span class='line'>public class BizViewModelName1ViewModel : BizViewModel
</span><span class='line'>{
</span><span class='line'>    public DateTime? SampleDate
</span><span class='line'>    {
</span><span class='line'>        get { return _sampleDate; }
</span><span class='line'>        set
</span><span class='line'>        {
</span><span class='line'>            SetProperty(ref _sampleDate, value);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    private DateTime? _sampleDate = DateTime.Now;
</span><span class='line'>
</span><span class='line'>    public void SampleAction()
</span><span class='line'>    {
</span><span class='line'>        MessageBox.Show(SampleDate.GetValueOrDefault().ToString("yyyy年MM月dd日"));
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>Xaml</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;TextBox Name="SampleTextBox" Text="{Binding Path=SampleDate, StringFormat=yyyy年MM月dd日}"/&gt;</span></code></pre></td></tr></table></div></figure>


<p>TextBox.Text プロパティにBindingクラスの指定と、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.path.aspx">Path</a> プロパティおよび<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.bindingbase.stringformat.aspx">StringFormat</a> プロパティを指定しています。
C#で記述するとしてもほぼ同じことを記述します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>BindingOperations.SetBinding(SampleTextBox, TextBox.TextProperty, new Binding("SampleDate") { StringFormat = "yyyy年MM月dd日" });</span></code></pre></td></tr></table></div></figure>


<p>WPF プロパティ システムを理解するということは、このBindingクラスの利用方法に他なりません。
どういうことか動かしながら確認したいと思います。</p>

<p>今まで通り、ボタンを押下するとViewModelのプロパティから値を取得してメッセージボックスを表示するアプリケーションです。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-08.png" alt="wpf-03-08" /></p>

<p>テキストボックスにキー入力で日付を変えボタンを押下すると、それがViewModelに自動で反映されている状態です。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-09.png" alt="wpf-03-09" /></p>

<p>現在、Binding クラスにはStringFormat以外何も指定していないにもかかわらず、いくつかの規定の動作が注入されています。<br/>
Binding クラスの機能を全て紹介するのは大変ですが、上記を通じて基本的なものを紹介します。</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> プロパティ</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.updatesourcetrigger.aspx">UpdateSourceTrigger</a> プロパティ</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.validationrules.aspx">ValidationRules</a> プロパティ</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.converter.aspx">Converter</a> プロパティ</li>
</ul>


<h2><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> /  <a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.updatesourcetrigger.aspx">UpdateSourceTrigger</a></h2>

<p>まず、現在の動作を確認するとTextBox.Text プロパティにキーボード入力で値を設定し、
ボタンを押下した（テキストボックスからフォーカスが外れた）タイミングでViewModelに画面上のデータが送信されています。</p>

<p>これは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> プロパティと<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.updatesourcetrigger.aspx">UpdateSourceTrigger</a> プロパティが関係しています。</p>

<p>TextBox.Text プロパティにバインディングした場合ですが、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> のデフォルト値は BindingMode.TwoWay となっています。<br/>
テキストボックスなのでキーボード入力が前提で、ViewModelのデータも表示する必要があるため、お互いにデータを双方向でやり取りするモードとなっています。</p>

<p>これがラベルのようにキーボード入力がない場合は、デフォルトのモードは OneWay となります。
多くの提供されているWPFコンテンツは Default で適切ですが、これを変更することができるのが<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> プロパティです。</p>

<p>先ほどの画面で<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> プロパティに OneWay と設定した場合、以下のようにViewModelにはデータが反映されなくなります。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-10.png" alt="wpf-03-10" /></p>

<p>次に、ロストフォーカスでView上のデータがViewModelに自動転送されている設定ですが、MSDNに記述があります。</p>

<blockquote><p>TextBox.Text プロパティの UpdateSourceTrigger の既定値は LostFocus です。</p></blockquote>

<p>WPF プロパティ システム はこれらの設定が既定で適用されている結果、開発者が深く意識しなくても動くアプリケーションが構築できるようになっています。</p>

<p>テキストボックスがロストフォーカス時にViewModelに値を転送するのには理由があります。</p>

<p>TextBox.Text プロパティはキー入力およびIMEでの候補を選択中でも値が変わります。
仮に UpdateSourceTrigger を PropertyChanged に、つまりText プロパティが変わる（≒キータイピング）のたびに
ViewModelへとデータ送信するようになると、想像通りアプリケーションは機能しなくなります。</p>

<h2><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.validationrules.aspx">ValidationRules</a></h2>

<p>ところで、ViewModel上はDateTime型で値を保持しているので、先ほどのテキストボックスで日付に変換できないような値を入力した場合、どうなるでしょう？
試してみます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-11.png" alt="wpf-03-11" /></p>

<p>ボタンを押下するためにフォーカスを外れると&hellip;</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-12.png" alt="wpf-03-12" /></p>

<p>テキストボックスが赤枠表示され、デバックログにはエラーがあった旨が出力されています。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>System.Windows.Data Error: 7 : ConvertBack cannot convert value '2014年10月99日' (type 'String'). BindingExpression:Path=SampleDate; DataItem='BizViewModelName1ViewModel' (HashCode=21817343); target element is 'TextBox' (Name='SampleTextBox'); target property is 'Text' (type 'String') FormatException:'System.FormatException: 文字列で表される DateTime がカレンダー System.Globalization.GregorianCalendar でサポートされていません。
</span><span class='line'>   場所 System.DateTime.Parse(String s, IFormatProvider provider)
</span><span class='line'>   場所 System.Convert.ToDateTime(String value, IFormatProvider provider)
</span><span class='line'>   場所 System.Convert.ChangeType(Object value, Type conversionType, IFormatProvider provider)
</span><span class='line'>   場所 System.Windows.Data.BindingExpression.ConvertBackHelper(IValueConverter converter, Object value, Type sourceType, Object parameter, CultureInfo culture)'</span></code></pre></td></tr></table></div></figure>


<p>これは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.validationrules.aspx">ValidationRules</a> プロパティに深く関係する、入力値の妥当性検証が規定で実行された結果になります。</p>

<p>この機能は奥深く、大きく三つのことを検討しなければなりません。</p>

<ul>
<li>検証ルールの定義</li>
<li>検証結果の視覚的フィードバック</li>
<li>検証を実行するタイミング</li>
</ul>


<p>これについてもMSDNに丁寧な記載があります。</p>

<blockquote><p>カスタム ErrorTemplate を提供しない場合、検証エラーがあった際にユーザーに視覚的にフィードバックするために、既定のエラー テンプレートが使用されることに注意してください。 詳細については、「データ バインドの概要」の「データの検証」を参照してください。 さらに WPF は、バインド ソース プロパティの更新中にスローされる例外をキャッチするための、組み込みの検証規則を提供します。 詳細については、「ExceptionValidationRule」を参照してください。</p></blockquote>

<p>先ほど学習したように、TextBox.Text プロパティの規定の<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.mode.aspx">Mode</a> プロパティは TwoWay つまり双方向通信します。<br/>
さらにそのタイミングを決定する<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.updatesourcetrigger.aspx">UpdateSourceTrigger</a> プロパティは LostFocus のため、フォーカスが外れるタイミングでバインド ソース プロパティ、つまりViewModelのプロパティを更新します。
ただし、2014年10月99日はDateTime型に変換できずエラーが発生した結果、組み込みの検証規則ExceptionValidationRuleが実行、赤枠の規定エラーテンプレートが適用されました。</p>

<ul>
<li>検証ルール

<ul>
<li>バインド ソース プロパティの更新中にスローされる例外をキャッチするための、組み込みの検証規則</li>
</ul>
</li>
<li>結果の外観

<ul>
<li>検証エラーがあった際にユーザーに視覚的にフィードバックするために、既定のエラー テンプレート</li>
</ul>
</li>
<li>検証を実行するタイミング

<ul>
<li>バインド ソース プロパティの更新（ViewのデータをViewModelへ送信しようとするタイミング）</li>
</ul>
</li>
</ul>


<p>これらが全て規定動作で動いた結果、現在の状態になっています。</p>

<p>では、Lob開発をするにあたっては、様々な入力検証（たとえば必須入力や型桁検証）を実行したい状況もあれば、その検証を適用するタイミングもロストフォーカスではなく、任意のタイミングで実行したいなどの要件も発生します。</p>

<p>これらの要件についても、今まで得たバインディングの知識を組み合わせることで、柔軟に対応できます。</p>

<p>UpdateSourceTrigger.Explicit という設定があります。
現在はロストフォーカス時にデータをViewModelへ転送する設定ですが、Explicit では開発者が明示的にデータ転送用のメソッドを呼び出すタイミングでそれが行われます。</p>

<p>では、さっそくコーディングしましょう！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;TextBox Text="{Binding Path=SampleDate, UpdateSourceTrigger=Explicit, StringFormat=yyyy年MM月dd日}" /&gt;</span></code></pre></td></tr></table></div></figure>


<p>これだけで、ロストフォーカスでValidationRuleが適用されることはなくなりました。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-13.png" alt="wpf-03-13" /></p>

<p>基本ですが、バインディングの肝要です。</p>

<p>ルールを新しく追加することなどもっと簡単で、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.validationrule.aspx">ValidationRule</a> クラスを派生して値を検証するロジックを記述し、それを利用する開発者に提供するだけです。</p>

<p>では、必須入力ルールを作成してみましょう。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class RequiredRule : ValidationRule
</span><span class='line'>{
</span><span class='line'>    public object ErrorContent
</span><span class='line'>    {
</span><span class='line'>        get { return errorContent; }
</span><span class='line'>        set { errorContent = value; }
</span><span class='line'>    }
</span><span class='line'>    private object errorContent = "Required fields.";
</span><span class='line'>
</span><span class='line'>    public override ValidationResult Validate(object value, System.Globalization.CultureInfo cultureInfo)
</span><span class='line'>    {
</span><span class='line'>        if (value == null)
</span><span class='line'>            return new ValidationResult(false, ErrorContent);
</span><span class='line'>        if (value is string && string.IsNullOrEmpty(value as string))
</span><span class='line'>            return new ValidationResult(false, ErrorContent);
</span><span class='line'>        return new ValidationResult(true, null);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>これを Binding.ValidationRules プロパティに Add する作業が必要ですが、それはどうとでもなります。<br/>
気にするとすれば、開発者が簡単かつ柔軟にValidationRule プロパティを拡張して適用できるように気を使うことです。</p>

<p>余談ですが、こういうライブラリを設計するアプローチもいろいろあり、楽しいものです。</p>

<p>『桁や必須かどうかというものは、データの属性である』というアプローチであったり、これを利用する開発イメージを処理と捉えてそこからスタートする方法もあります。</p>

<p>設計するアプローチは様々あり、それを選択していることを受け入れるいうことは重要です。<br/>
与太話でしたが、まとめるとこんなイメージで！</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-14.png" alt="wpf-03-14" /></p>

<p>開発者は、バインドしているデータの書式および必須ルールを属性として利用できるようなイメージです。
このライブラリを開発する際に気にすることがあるとすれば、ルールは開発者が容易に拡張できるようなソリューションだと思います。</p>

<p>ところで、上述の RequiredRule ではデータ単体に着目したのですが、相関的な検証ルールはどうでしょうか。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.validationrule.aspx">ValidationRule</a> クラスをMSDNで確認すると、すでにいくつかの派生クラスが規定で用意されています。</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.exceptionvalidationrule.aspx">ExceptionValidationRule</a> クラス

<ul>
<li>既定で適用されていることを確認しました。</li>
</ul>
</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.dataerrorvalidationrule.aspx">DataErrorValidationRule</a> クラス</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.notifydataerrorvalidationrule.aspx">NotifyDataErrorValidationRule</a> クラス</li>
</ul>


<p>これらは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.validationrules.aspx">ValidationRules</a> プロパティに追加せずとも、自動で有効になるようなオプションが Binding クラスに用意されています。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;TextBox Text="{Binding Path=SampleDate, ValidatesOnDataErrors=True}"/&gt;
</span><span class='line'>&lt;TextBox Text="{Binding Path=SampleDate, ValidatesOnExceptions=True}"/&gt;
</span><span class='line'>&lt;TextBox Text="{Binding Path=SampleDate, ValidatesOnNotifyDataErrors=True}"/&gt;</span></code></pre></td></tr></table></div></figure>


<p>多くは規定で適用されており、これらを明示的に意識する必要はありません。</p>

<p>また、<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.notifydataerrorvalidationrule.aspx">NotifyDataErrorValidationRule</a> クラスは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.dataerrorvalidationrule.aspx">DataErrorValidationRule</a> クラスの上位機能になります。<br/>
（NotifyDataErrorValidationRule は .Net Framework4.5 で提供されました。）</p>

<p>話を戻すと、この用意されているルールを利用して相関的な検証ロジックを実装する方法について紹介します。</p>

<p>この機能はView（ターゲット）からViewModel（データソース）へと値を転送した後にその値を保持するクラスが
<a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.inotifydataerrorinfo.aspx">INotifyDataErrorInfo</a> インターフェイスを実装していれば、自動で有効になる機能です。</p>

<p>今のサンプルを例にしてみると、 ViewModel の SampleDate プロパティを TextBox.Text プロパティにバインドしています。
TextBoxに値を入力しそれが例外なくSampleDateに転送できた場合に、ViewModelが<a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.inotifydataerrorinfo.aspx">INotifyDataErrorInfo</a> インターフェイスを実装していれば、自動で検証メソッドが実行されます。</p>

<p>この仕組みによって ViewModel上で、複数のプロパティを比較しながら、データの妥当性検証が可能になります。<br/>
これはビジネス エンティティのカプセル化を支援します。</p>

<p>どういうことかといえば、ある業務機能を実装するクラスがあったとします。<br/>
それは Entity Framework を利用したPOCOクラスかもしれないし、型付きDataSetかもしれないし、もしくは業務専用クラスかもしれません。</p>

<p>それらの属性をバインドしているならば、そのクラスが<a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.inotifydataerrorinfo.aspx">INotifyDataErrorInfo</a> インターフェイスを実装することで、そのクラスに閉じた形で検証処理を実装することができます。
このインターフェイスは標準で参照している .Net Framework の System.dll が提供するので、WPFなどのプレゼンテーション テクノロジーとは切り離されています。</p>

<p>MSが提供する <a href="http://www.microsoft.com/ja-jp/dev/2010/solutions/architecture/default.aspx">Application Architecture Guide 2.0</a> では一般的な開発レイヤとして以下の図で説明しています。</p>

<p><img src="http://s-ueno.github.io/images/wpf-03-15.png" alt="wpf-03-15" /></p>

<p>ビジネスレイヤーでビジネスエンティティに検証ロジックをカプセル化し、それが自動でプレゼンテーション レイヤで有効化できるようなソリューションです。</p>

<p>ここまでで、単項目の検証ルールおよび複数項目の検証ルールが定義できるようになりました。</p>

<ul>
<li>検証ルールの定義</li>
<li>検証結果の視覚的フィードバック</li>
<li>検証を実行するタイミング</li>
</ul>


<p>あとは『検証結果の視覚的フィードバック』ですが、これはWPFテクノロジーのもう一つの肝要であるテンプレートを紹介する際にしたいと思います。
今は既定の視覚的フィードバックをそのまま利用しましょう。</p>

<h2><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.converter.aspx">Converter</a></h2>

<p>さて、最後に<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.binding.converter.aspx">Converter</a> プロパティについて紹介します。</p>

<p>これは StringFormat プロパティと比べ、よりリッチな変換を適用できます。</p>

<p>例えば、ViewModel上のプロパティ値が列挙体(None,Error,Complete)だった場合に、その列挙体にあったイメージ画像を返すみたいなグル（接着剤）コードをConverterクラスにカプセル化できます。</p>

<p>MSDNのサンプルコードでは</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[ValueConversion(typeof(DateTime), typeof(String))]
</span><span class='line'>public class DateConverter : IValueConverter
</span><span class='line'>{
</span><span class='line'>    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
</span><span class='line'>    {
</span></code></pre></td></tr></table></div></figure>


<p>という風にIValueConverterインターフェイスの実装と合わせて、ValueConversion属性も付与しています。<br/>
これは自分が作業する分だけなのであれば特に不要なのですが、共通ライブラリなどを作成した際に、それを利用する開発者に対してのメッセージになります。</p>

<p>WPFは自由度が高い反面、ルールがないと意図しない結果になる可能性があります。
たとえばですが、開発者はXaml上でコンボボックスを正しくコーディングしていたとしても、テンプレートというスタイルを書き換える機能が適用された場合は、それがラジオボタンに差し替わって表示されることなど容易に可能です。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/ms752339.aspx">MSDNのこの記事</a>など読むと面白いのですが</p>

<blockquote><p>このベスト プラクティスは、組み込みの WPF コントロール セット用のテーマ コントロール スタイルでの作業の際に、多くの試行錯誤を通じて得られたものです。</p></blockquote>

<p>マイクロソフト内部でもいろいろと苦労したことが伺えます。</p>

<p>例として<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.combobox.aspx">ComboBox</a>クラスを見ると様々な属性を持っていますが、この情報は後に柔軟なスタイルおよびデザイン（機能性）を実現する上でとても重要なものとなります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[Localizability(LocalizationCategory.ComboBox)]
</span><span class='line'>[TemplatePart(Name = "PART_EditableTextBox", Type = typeof(TextBox))]
</span><span class='line'>[TemplatePart(Name = "PART_Popup", Type = typeof(Popup))]
</span><span class='line'>[StyleTypedProperty(Property = "ItemContainerStyle", StyleTargetType = typeof(ComboBoxItem))]
</span><span class='line'>public class ComboBox : Selector
</span><span class='line'>
</span><span class='line'>/*
</span><span class='line'>今はWPFの基本を解決している最中でが、応用してテンプレートを利用する世界では、
</span><span class='line'>技術資産を蓄積できるようになります。
</span><span class='line'>
</span><span class='line'>その際にはコンボボックスをカスタマイズしたスタイルの適用や、
</span><span class='line'>添付プロパティによるカスタマイズなどを紹介したいと思います。
</span><span class='line'>*/
</span></code></pre></td></tr></table></div></figure>


<p>ライブラリとしてIValueConverterを提供する場合は、開発者へのメッセージとしてValueConversion属性をつけてね、ということなのですが・・・</p>

<p>確かに、Xaml上でIValueConverterを適用するためには日付用とか●×用とか何個も専用のクラスを作成する必要があります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    &lt;StackPanel Grid.Row="0" Grid.Column="1" Orientation="Horizontal" Margin="5" &gt;
</span><span class='line'>        &lt;StackPanel.Resources&gt;
</span><span class='line'>            &lt;local:DateConverter x:Key="dateConverter"/&gt;
</span><span class='line'>        &lt;/StackPanel.Resources&gt;
</span><span class='line'>        &lt;TextBox Name="ConverterTextBox" Text="{Binding Path=SampleDate, Converter={StaticResource dateConverter}, ConverterParameter=arg}"/&gt;
</span><span class='line'>    &lt;/StackPanel&gt;
</span></code></pre></td></tr></table></div></figure>


<p>ただ、<a href="https://www.google.com/search?q=Expression+Builder%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Expression Builder</a>パターンでコードビハインド上でのコーディングを採用するとしたら、以下で多くは解決できます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>    public class SimpleConverter : IValueConverter
</span><span class='line'>    {
</span><span class='line'>        public Func&lt;object, Type, object, CultureInfo, object&gt; ConvertMethod { get; set; }
</span><span class='line'>        public Func&lt;object, Type, object, CultureInfo, object&gt; ConvertBackMethod { get; set; }
</span><span class='line'>        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
</span><span class='line'>        {
</span><span class='line'>            if (ConvertMethod != null)
</span><span class='line'>                return ConvertMethod(value, targetType, parameter, culture);
</span><span class='line'>            throw new NotImplementedException();
</span><span class='line'>        }
</span><span class='line'>        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
</span><span class='line'>        {
</span><span class='line'>            if (ConvertBackMethod != null)
</span><span class='line'>                return ConvertBackMethod(value, targetType, parameter, culture);
</span><span class='line'>            throw new NotImplementedException();
</span><span class='line'>        }
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>


<p>WPFテクノロジー依存であり、Viewのコードビハインド上に静的メソッドを用意すればかなりシンプルになります。</p>

<p>IValueConverter としてはシステムで共通的なロジックの部品化という視点で拡張すればと思います。
ただ、多くはアドホックで業務（≒画面）固有なので、上記のようなメソッド指定が活躍することは多いです。</p>

<p>以上で、バインディングの基本でありながら、WPFの肝要となる機能の紹介でした。</p>

<p>これらの動作を確認するためのサンプルは<a href="http://s-ueno.github.io/additionalData/uEN-Vol03.zip">コチラ</a></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WPF ViewModelでLOB開発 Vol 02 - ルーティング イベント]]></title>
    <link href="http://s-ueno.github.io/blog/2014/10/01/wpf-02/"/>
    <updated>2014-10-01T14:00:00+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/10/01/wpf-02</id>
    <content type="html"><![CDATA[<p>最初に簡単に<a href="http://msdn.microsoft.com/ja-jp/library/ms247121.aspx">ItemTemplates</a>について紹介して、<a href="http://msdn.microsoft.com/ja-jp/library/ms742806.aspx">ルーティング イベント</a>とビューモデルの紐付おまじないコードの解決を図りたいと思います。</p>

<!-- more -->


<p>たとえばVisualStudio2013をインストールすると、
C:\Users\&ldquo;username&rdquo;\Documents\Visual Studio 2013\Templates\
というフォルダができていると思います。</p>

<p>ここに以下の作業を実施します。</p>

<ul>
<li>【ItemTemplates】フォルダ - 【Visual C#】フォルダの中に新規フォルダ作成（uEN Laboratory）</li>
<li>この<a href="http://s-ueno.github.io/additionalData/BizViewModel.zip">ZIPファイル</a>を先ほどのフォルダに入れる</li>
</ul>


<p>そうすると、クラスの新規追加時に雛形を提供することができます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-02-01.png" alt="wpf-02-01" /></p>

<p>ViewクラスとVeiwModelクラスがセットで追加されます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-02-02.png" alt="wpf-02-02" /></p>

<p>名前空間などはテンプレートがサポートします。</p>

<p><img src="http://s-ueno.github.io/images/wpf-02-03.png" alt="wpf-02-03" />
<img src="http://s-ueno.github.io/images/wpf-02-04.png" alt="wpf-02-04" /></p>

<p>前回はベースクラス名を変えたり、Xamlに名前空間をインポートしたりとかなり手間だったのですが、この機能を利用すると毎回同じ作業を実施しなくて済むようになります。
WPFでの開発生産性を上げる上ではとても有効なので、ぜひ利用してみてください。</p>

<p>カスタマイズするには、さっきのZIPファイルやMSDNを参考にすると簡単にできるのでチェックしてみてください。</p>

<h2>ルーティング イベント</h2>

<p>ボタン押下などのイベント処理を簡単に実装するためには、またおまじないコードが必要になります。<br/>
<a href="http://ja.wikipedia.org/wiki/Model_View_ViewModel">Model-View-ViewModel</a> デザイン パターンを利用しない場合は、Xaml（ザムル）上でダブルクリックすると、Xaml.CSファイルのコードビハインドにクリックイベントが紐付けられます。</p>

<p><img src="http://s-ueno.github.io/images/wpf-02-05.png" alt="wpf-02-05" />
<img src="http://s-ueno.github.io/images/wpf-02-06.png" alt="wpf-02-06" /></p>

<p>ただ、これでは画面をXamlで作成するという難易度だけ上がって、Windows Formとあまり変わりません。
そこで、このイベント処理もバインディングできればと思います。</p>

<p>上記の実装ですが、明示的にRoutedEventを利用してコードビハインド上で記述することもできます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SampleButton.AddHandler(Button.ClickEvent, new RoutedEventHandler(SampleButton_Click));</span></code></pre></td></tr></table></div></figure>


<p><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.buttonbase.clickevent.aspx">Button.ClickEvent</a> は　Buttonクラスに静的に定義され、開発者が利用できるように提供されています。</p>

<p>この仕組みを利用することで、指定したオブジェクトが指定したRoutedEventを実行する際の処理をどこか別の場所（具体的にはViewModel）に定義することができるようになります。</p>

<p><a href="http://ja.wikipedia.org/wiki/Proxy_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Proxyパターン</a>を利用したラッパー経由でViewModelのメソッドに割り付けるようなクラスを準備すれば十分ではないでしょうか。
前回、バインドをタイプセーフに行うためにラムダ式でプロパティ名を指定したように、このイベントの紐付けもラムダ式で行うようにしたいと思います。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class RoutedEventBehavior
</span><span class='line'>{
</span><span class='line'>    public RoutedEvent RoutedEvent { get; set; }
</span><span class='line'>    public object ViewModel { get; set; }
</span><span class='line'>    public DependencyObject Element { get; set; }
</span><span class='line'>    public LambdaExpression LambdaExpression { get; set; }
</span><span class='line'>    protected Action Method { get; set; }
</span><span class='line'>    protected Action&lt;RoutedEventArgs&gt; ArgsMethod { get; set; }
</span><span class='line'>    public virtual void Ensure()
</span><span class='line'>    {
</span><span class='line'>        var uiElement = Element as UIElement;
</span><span class='line'>        if (uiElement == null)
</span><span class='line'>            return;
</span><span class='line'>
</span><span class='line'>        if (Method == null && ArgsMethod == null)
</span><span class='line'>        {
</span><span class='line'>            var compile = LambdaExpression.Compile().DynamicInvoke(ViewModel);
</span><span class='line'>            Method = compile as Action;
</span><span class='line'>            ArgsMethod = compile as Action&lt;RoutedEventArgs&gt;;
</span><span class='line'>        }
</span><span class='line'>        uiElement.AddHandler(RoutedEvent, new RoutedEventHandler(OnEventInternal));
</span><span class='line'>    }
</span><span class='line'>    protected virtual void OnEventInternal(object sender, RoutedEventArgs e)
</span><span class='line'>    {
</span><span class='line'>        var currentCursor = Mouse.OverrideCursor;
</span><span class='line'>        Mouse.OverrideCursor = System.Windows.Input.Cursors.Wait;
</span><span class='line'>        try
</span><span class='line'>        {
</span><span class='line'>            if (Method != null)
</span><span class='line'>                Method.Invoke();
</span><span class='line'>
</span><span class='line'>            if (ArgsMethod != null)
</span><span class='line'>                ArgsMethod.Invoke(e);
</span><span class='line'>        }
</span><span class='line'>        catch (Exception)
</span><span class='line'>        {
</span><span class='line'>            //エラー時のアプリケーション ポリシー
</span><span class='line'>            throw;
</span><span class='line'>        }
</span><span class='line'>        finally
</span><span class='line'>        {
</span><span class='line'>            Mouse.OverrideCursor = currentCursor;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>サンプル程度の実装ですが、こうすることで、ボタン押下時のマウスカーソルの自動Wait化やエラー時のロギングなどを開発者が実装する必要がなくなります。
ログ出力には、<a href="http://msdn.microsoft.com/ja-jp/library/System.Diagnostics.TraceSource.aspx">TraceSource</a>クラスを利用すると便利なので、別の機会に紹介します。</p>

<p>また、開発者が直接このようなクラスを生成する手間は省きたいです。<br/>
たとえば<a href="https://www.google.com/search?q=Expression+Builder%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Expression Builderパターン</a>なんてプログラミング デザイン パターンを採用してみれば、開発がしやすく可読性があがるかもしれません。</p>

<p>画面上にテキストボックス、ボタンが配置されている場合のコーディング イメージとしてはこのような形でしょうか？</p>

<p><img src="http://s-ueno.github.io/images/wpf-02-07.png" alt="wpf-02-07" /></p>

<p>コントロールを指定して、依存関係プロパティないしルーティング イベントとViewModelのメソッドをタイプセーフに紐付けるビルダーを利用してバインドするという形です。</p>

<p>このコードを記述して実際に動かすとこのようになります。</p>

<p><img src="http://s-ueno.github.io/images/wpf-02-08.png" alt="wpf-02-08" /></p>

<p>テキストボックスに文字を入力し、ボタンをクリックするとViewModel上のSampleActionメソッドが呼び出され、バインドしているSampleTextプロパティから文字を取得してメッセージ表示しています。</p>

<p>ツールレベルならコレでも十分かもしれませんが、実際のLOB開発時には画面に表示する際に変換（<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.data.ivalueconverter.aspx">IValueConverter</a>）する、入力制限する、他にも様々な作業が発生するので、次回は少しこのバインディングについて掘り下げていきたいと思います。</p>

<p>余談ですが、Buttonクラスは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.primitives.buttonbase.command.aspx">Command</a>というプロパティを提供しています。<br/>
こちらを利用することでもボタンのクリックイベント処理を実装することができるのですが、この仕組みはLOBアプリのとあるボタンの押下処理とは意味合いが少し異なることを<a href="http://msdn.microsoft.com/ja-jp/library/ms752308.aspx">目的</a>にしています。</p>

<p>LOBアプリでのイベント処理はルーティング イベントを利用するほうがシンプルです。
コマンドについては別の機会で紹介できればと思います。</p>

<p>今回のサンプルは<a href="http://s-ueno.github.io/additionalData/uEN-Vol02.zip">コチラ</a></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WPF ViewModelでLOB開発 Vol 01 - WPFプロパティ システム]]></title>
    <link href="http://s-ueno.github.io/blog/2014/09/11/wpf-01/"/>
    <updated>2014-09-11T12:03:19+09:00</updated>
    <id>http://s-ueno.github.io/blog/2014/09/11/wpf-01</id>
    <content type="html"><![CDATA[<p>LOB開発といえば企業が利用する業務システムで、Windows FormとSQLを利用して、あっという間にデータベースと連係して動くアプリケーションを作成できる技術者は多いと思います。</p>

<p>そんなところに出てきたWPF(Windows Presentation Foundation)。<br/>
とても優れた技術ですが、これをどうLOB開発として利用するかは少し敷居があるのかと感じています。</p>

<p>『WPF ViewModelでLOB開発』シリーズでは、WPFの恩恵を十分に受けつつ、より簡単に開発するための情報を展開します。</p>

<!-- more -->


<h2>WPFテクノロジー</h2>

<p>技術詳細については<a href="http://msdn.microsoft.com/ja-jp">MSDN</a> か <a href="http://blogs.msdn.com/b/shozoa/">荒井省三さんのBlog</a> のWPF編を読むことをお勧めします。<br/>
ここではVisualStudioを利用しながら動かすことに視点を合わせたいと思います。</p>

<h2>ViewModel</h2>

<p>ビューモデルと呼び、この連載タイトルの一部にも登場しています。<br/>
<a href="http://ja.wikipedia.org/wiki/Model_View_ViewModel">Model-View-ViewModel</a> というデザイン パターンの中で、画面の状態を持つオブジェクトです。
Wikiを読むと難しく早くも挫折しそうですが、手を動かしながら確認したいと思います。</p>

<p>Visual Studioを起動して SimpleApp というWPFアプリケーションを作成
<img src="http://s-ueno.github.io/images/wpf-01-01.png" alt="wpf-01-01" />
<img src="http://s-ueno.github.io/images/wpf-01-02.png" alt="wpf-01-02" /></p>

<p>自動でxamlが二つ生成されています。</p>

<ul>
<li>App.xaml

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.application.aspx">System.Windows.Application</a> クラスから派生し、WPFアプリを起動する役目を持ちます。
　</li>
</ul>
</li>
<li>MainWindowo.xaml

<ul>
<li>メイン画面で、Model-View-ViewModel でいうところの View になります。  今回は中央にSampleTextBoxという名前を付けたテキストボックスを配置しました。</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> &lt;TextBox Name="SampleTextBox"/&gt;</span></code></pre></td></tr></table></div></figure>


<p>ここに MainWindow の状態を持つための ViewModel を追加します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-03.png" alt="wpf-01-03" />
<img src="http://s-ueno.github.io/images/wpf-01-04.png" alt="wpf-01-04" /></p>

<p>Textという文字列型のプロパティを持ち、コンストラクタで初期化しています。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class MainWindowViewModel
</span><span class='line'>{
</span><span class='line'>    public MainWindowViewModel()
</span><span class='line'>    {
</span><span class='line'>        Text = "これはテスト文字列です。";
</span><span class='line'>    }
</span><span class='line'>    public string Text { get; set; }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>次に MainWindow という ビュー が ビューモデル を利用してデータを表示するための設定を行います。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-05.png" alt="wpf-01-05" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// &lt;summary&gt;
</span><span class='line'>/// MainWindow.xaml の相互作用ロジック
</span><span class='line'>/// &lt;/summary&gt;
</span><span class='line'>public partial class MainWindow : Window
</span><span class='line'>{
</span><span class='line'>    public MainWindow()
</span><span class='line'>    {
</span><span class='line'>        InitializeComponent();
</span><span class='line'>
</span><span class='line'>        this.DataContext = new MainWindowViewModel();
</span><span class='line'>        
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>DataContext というプロパティ名が表すように、ここに設定したオブジェクトがデータを表すということになります。<br/>
これで ViewModel の設定は完了しました。</p>

<p>ここからさらに各コントロール（ここではテキストボックスだけですが）の データ バインディング を行います。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-06.png" alt="wpf-01-06" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>this.SampleTextBox.SetBinding(TextBox.TextProperty, new Binding("Text"));</span></code></pre></td></tr></table></div></figure>


<p>バインディングの方法は様々でXaml(ザムル)といわれる画面を構成するXML上で
<code>&lt;TextBox Name="SampleTextBox" Text="{Binding Path=Text}"/&gt;</code>
と記述することも可能ですが、ここでは意図してコード上でバインディングしています。</p>

<p>TextBox.TextProperty は依存関係プロパティといい、このバインディングの仕組みは<a href="http://msdn.microsoft.com/ja-jp/library/ms752914.aspx">WPF プロパティ システム</a>と呼ばれます。
Bindingクラスのコンストラクタ パラメーターは ViewModel のプロパティ名を設定しています。
この状態でF5キーを押下してデバック実行すると・・・</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-07.png" alt="wpf-01-07" /></p>

<p>表示されましたね！<br/>
フレキシブル レイアウトで、テキストボックスは画面を大きくすると画面と一緒に大きくなります。</p>

<p>画面での入力内容が、DataContext に設定したオブジェクトのプロパティに自動設定されるなどの一連のバインディングの仕組みが用意されており、
この仕組みを利用するのが<a href="http://ja.wikipedia.org/wiki/Model_View_ViewModel">Model-View-ViewModel</a> デザイン パターンです。</p>

<p>注目するのはMainWindowViewModelクラスで、UIから独立した素のクラスです。<br/>
従来の画面とモデルを紐付けるよなグル(接着剤)コードがViewModel上には出てこなくなりました。</p>

<h2>LOB開発基盤　-　ViewModel</h2>

<p>さて、ここまでで発生した「おまじないコード」は・・・</p>

<ul>
<li>WindowのDataContextプロパティへの設定</li>
<li>TextBox.TextPropertyという依存関係プロパティを利用したバインディング作業</li>
</ul>


<p>になります。<br/>
まだまだ記述していないおまじないコードもあり、このままではLOB開発に展開できません。</p>

<p>これらのおまじないコードを基底クラスと一連の機能に隠ぺいすることで、最終的にはViewModelで簡単に画面遷移できるようなソリューションになれれば、WPFの恩恵を受けながらLOB開発を進められるかも？！</p>

<p>基盤はこれからのシリーズで少しずつ機能を固めていくので、まずは準備しましょう。
まずは <a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.inotifypropertychanged.aspx">INotifyPropertyChanged</a> インターフェイスを実装したViewModelのベースクラスを準備します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-08.png" alt="wpf-01-08" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public abstract class BizViewModel : INotifyPropertyChanged
</span><span class='line'>{
</span><span class='line'>    public event PropertyChangedEventHandler PropertyChanged;
</span><span class='line'>    public void OnPropertyChanged(string propertyName = null)
</span><span class='line'>    {
</span><span class='line'>        if (PropertyChanged != null)
</span><span class='line'>            PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
</span><span class='line'>    }
</span><span class='line'>    protected bool SetProperty&lt;T&gt;(ref T storage, T value, 
</span><span class='line'>        [CallerMemberName] string propertyName = null)
</span><span class='line'>    {
</span><span class='line'>        if (object.Equals(storage, value))
</span><span class='line'>            return false;
</span><span class='line'>
</span><span class='line'>        storage = value;
</span><span class='line'>        OnPropertyChanged(propertyName);
</span><span class='line'>        return true;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ソースコードは<a href="http://blogs.msdn.com/b/shozoa/">荒井省三さんのBlog</a>で紹介されているものを拝借しました。
ポイントは二つで</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.inotifypropertychanged.aspx">INotifyPropertyChanged</a> インターフェイス</li>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.runtime.compilerservices.callermembernameattribute.aspx">CallerMemberName</a> 属性</li>
</ul>


<p>になります。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.componentmodel.inotifypropertychanged.aspx">INotifyPropertyChanged</a> インターフェイスは、データ バインディングの仕組みの一つで、何かの処理を実行してViewModelのプロパティに値をセットした場合、それをView側に通知する機能です。
この仕組みで、画面上のデータが再描画されます。<br/>
プロパティのsetで呼び出すようにします。</p>

<p><a href="http://msdn.microsoft.com/ja-jp/library/system.runtime.compilerservices.callermembernameattribute.aspx">CallerMemberName</a> 属性は.Net4.5で新しく出てきた機能で、呼び出し元のメンバー名を自動設定してくれる機能です。
少し前までは、プロパティのsetで <code>OnPropertyChanged("●×プロパティ名")</code> みたいにコーディングしていたのですが、その文字を記述する必要がなくなりました。
.Net4.0以前では利用できませんが、必須な属性ではなく、文字列でプロパティ名をコーディングしていた世界から少しだけタイプセーフになりましたというところです。</p>

<p>こういうおまじないコードをViewModelの基底クラスに準備しておくことにします。</p>

<p>次にバインディングの作業です。
先ほどタイプセーフと呼びましたが、なるべくコンパイラのチェックが働くようなコーディングだとソースコードの量が増えたときに便利です。
そこで、バインディングのときにコーディングした</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>new Binding("Text")</span></code></pre></td></tr></table></div></figure>


<p>ここの&#8221;Text&#8221;というプロパティ名もタイプセーフにセットできるようにしたいと思います。</p>

<p>これはWPFとは関係のない、ただの技術情報なのですが、<a href="http://msdn.microsoft.com/ja-jp/library/bb397687.aspx">ラムダ</a>というコーディングの記述方法があります。<br/>
LINQが利用されるようになってきて、このラムダにおける型の推論によるコーディング方法も浸透してきたと思います。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//LINQというのは、こんな感じ
</span><span class='line'>IEnumerable&lt;Customer&gt; customers = customers.Where(c =&gt; c.City == "London");
</span></code></pre></td></tr></table></div></figure>


<p>C#の経験があるといってもラムダを初めてみる人は、 <code>c =&gt; c.City == "London"</code> の記述を見るとびっくりするかもしれませんが、VisualStudioでインテリセンスが働くので、すぐに慣れると思います。</p>

<p>このラムダを利用して、タイプセーフにViewModelのプロパティ名を取得するような簡単なユーティリティを準備します。
こういうのはすでに世の中に出回っているので、<a href="http://themechanicalbride.blogspot.jp/2007/03/symbols-in-c-30-reloaded.html">探せば出てきます</a>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class ExpressionExtensions
</span><span class='line'>{
</span><span class='line'>    public static string ToPropertyName&lt;T&gt;(this T obj, Expression&lt;Func&lt;T, object&gt;&gt; expr)
</span><span class='line'>    {
</span><span class='line'>        return expr.ToSymbol();
</span><span class='line'>    }
</span><span class='line'>    public static string ToSymbol(this Expression expr)
</span><span class='line'>    {
</span><span class='line'>        if (expr == null)
</span><span class='line'>            return null;
</span><span class='line'>
</span><span class='line'>        var memExp = (expr as LambdaExpression).Body as MemberExpression;
</span><span class='line'>        var list = new List&lt;string&gt;();
</span><span class='line'>        while (memExp is MemberExpression)
</span><span class='line'>        {
</span><span class='line'>            list.Add(memExp.Member.Name);
</span><span class='line'>            memExp = memExp.Expression as MemberExpression;
</span><span class='line'>        }
</span><span class='line'>        return string.Join(".", list.Reverse&lt;string&gt;());
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>あとは MainWindowViewModel のベースクラスを BizViewModel として</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class MainWindowViewModel : BizViewModel
</span><span class='line'>{
</span><span class='line'>    public MainWindowViewModel()
</span><span class='line'>    {
</span><span class='line'>        Text = "これはテスト文字列です。";
</span><span class='line'>    }
</span><span class='line'>    public string Text
</span><span class='line'>    {
</span><span class='line'>        get { return text; }
</span><span class='line'>        set
</span><span class='line'>        {
</span><span class='line'>            SetProperty(ref text, value);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    private string text; 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>さっきのユーティリティを利用すると</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-09.png" alt="wpf-01-09" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// &lt;summary&gt;
</span><span class='line'>/// MainWindow.xaml の相互作用ロジック
</span><span class='line'>/// &lt;/summary&gt;
</span><span class='line'>public partial class MainWindow : Window
</span><span class='line'>{
</span><span class='line'>    public MainWindow()
</span><span class='line'>    {
</span><span class='line'>        InitializeComponent();
</span><span class='line'>
</span><span class='line'>        var viewModel = new MainWindowViewModel();
</span><span class='line'>        this.DataContext = viewModel;
</span><span class='line'>
</span><span class='line'>        var textPropertyName = viewModel.ToPropertyName(x =&gt; x.Text);
</span><span class='line'>        this.SampleTextBox.SetBinding(TextBox.TextProperty, new Binding(textPropertyName));
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>これでコンパイラでチェックがかかるタイプセーフなWPFの簡単な基盤ができました。
イベント系などは次回紹介するとして、今はViewおよびViewModelの役割を設定していきたいと思います。</p>

<h2>LOB開発基盤　-　View</h2>

<p>次にViewについて少し掘り下げていきます。
今はWindowのXamlに直接記述しています。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Window x:Class="SimpleApp.MainWindow"
</span><span class='line'>        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
</span><span class='line'>        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
</span><span class='line'>        Title="MainWindow" Height="350" Width="525"&gt;
</span><span class='line'>    &lt;Grid&gt;
</span><span class='line'>        &lt;TextBox Name="SampleTextBox"/&gt;
</span><span class='line'>    &lt;/Grid&gt;
</span><span class='line'>&lt;/Window&gt;</span></code></pre></td></tr></table></div></figure>


<p>Windowタグの中には一つのコンテンツのみを配置できます。<br/>
今は <code>&lt;Grid&gt;</code> が配置されています。コードで記述すると</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// &lt;summary&gt;
</span><span class='line'>/// MainWindow.xaml の相互作用ロジック
</span><span class='line'>/// &lt;/summary&gt;
</span><span class='line'>public partial class MainWindow : Window
</span><span class='line'>{
</span><span class='line'>    public MainWindow()
</span><span class='line'>    {
</span><span class='line'>        InitializeComponent();
</span><span class='line'>
</span><span class='line'>        this.Content = new Grid();</span></code></pre></td></tr></table></div></figure>


<p>なので、コンテンツは一つのみとなります。
ただし、このコンテンツがどのように描画されるかはWPFの拡張機能によって変わってきます。</p>

<p>試しにデバック実行し、WPFビジュアライザーで確認してみると</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-10.png" alt="wpf-01-10" /></p>

<p>MainWindowの中にあるContentPresenterにGridが配置されています。<br/>
別の機会に詳しく紹介しますが、WPFの<a href="http://msdn.microsoft.com/ja-jp/library/ms745683.aspx">Style</a>が適用されている結果このような表示になります。</p>

<p>少し前までAero.NormalColor.xamlなどスタイルがMSDNからダウンロードできたのですが、リンクが見つかりませんでした。
現在のデバック実行した環境でWindowクラスに適用されているスタイルは、以下のようになっているのだと思います。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;Style x:Key="{x:Type Window}"
</span><span class='line'>       TargetType="{x:Type Window}"&gt;
</span><span class='line'>    &lt;Setter Property="Foreground"
</span><span class='line'>            Value="{DynamicResource {x:Static SystemColors.WindowTextBrushKey}}"/&gt;
</span><span class='line'>    &lt;Setter Property="Background"
</span><span class='line'>            Value="{DynamicResource {x:Static SystemColors.WindowBrushKey}}"/&gt;
</span><span class='line'>    &lt;Setter Property="Template"&gt;
</span><span class='line'>        &lt;Setter.Value&gt;
</span><span class='line'>            &lt;ControlTemplate TargetType="{x:Type Window}"&gt;
</span><span class='line'>                &lt;Border Background="{TemplateBinding Background}"
</span><span class='line'>                        BorderBrush="{TemplateBinding BorderBrush}"
</span><span class='line'>                        BorderThickness="{TemplateBinding BorderThickness}"&gt;
</span><span class='line'>                    &lt;AdornerDecorator&gt;
</span><span class='line'>                        &lt;ContentPresenter/&gt;
</span><span class='line'>                    &lt;/AdornerDecorator&gt;
</span><span class='line'>                &lt;/Border&gt;
</span><span class='line'>            &lt;/ControlTemplate&gt;
</span><span class='line'>        &lt;/Setter.Value&gt;
</span><span class='line'>    &lt;/Setter&gt;</span></code></pre></td></tr></table></div></figure>


<p>TemplateというWPFの外観をカスタマイズできる機能があり、ここにコンテンツを表示する際はBorderを用意して、AdornerDecoratorを用意してその中にContentPresenterを・・・という風に定義されています。</p>

<p>話を戻すと、Windowに表示されるコンテンツは<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.contentpresenter.aspx">ContentPresenter</a>を利用して表示されるようになっています。</p>

<p>MSDNの<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.contentpresenter.aspx">ContentPresenter</a>をみると、コンテンツがどのようなロジックで表示するかの記述があります。
たとえば、コンテンツに文字列を設定するとTextBlockが自動で作成されて、表示されるようになります。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-11.png" alt="wpf-01-11" /></p>

<p><img src="http://s-ueno.github.io/images/wpf-01-12.png" alt="wpf-01-12" /></p>

<p>F5キーでデバック実行</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-13.png" alt="wpf-01-13" /></p>

<p>任意のクラスの場合はToStringの結果が表示されるのですが、その場合に何を表示すべきかをカスタマイズする機能があります。</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.windows.controls.contentcontrol.contenttemplateselector.aspx">ContentControl.ContentTemplateSelector</a> プロパティ</li>
</ul>


<p>試しにContentTemplateSelectorプロパティに設定して動作確認してみましょう。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-14.png" alt="wpf-01-14" /></p>

<p>戻り値の<a href="http://msdn.microsoft.com/ja-jp/library/system.windows.datatemplate.aspx">DataTemplate</a>はビジュアル要素（つまりView）をあらわし、引数のitemは任意のデータをあらわします。<br/>
この仕組みの面白いところは、<strong>データがビジュアル要素を決定する</strong>というところです。
つまり、ビジュアル要素はデータの属性として表現すると、仕組みを上手に利用できそうだとわかります。</p>

<p>さっそくオブジェクトとしてそれを表現してみたいと思います。<br/>
ビジュアル要素はデータの属性として扱うので</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class VisualElementsAttribute : Attribute
</span><span class='line'>{
</span><span class='line'>    public VisualElementsAttribute(Type visualType)
</span><span class='line'>    {
</span><span class='line'>        VisualType = visualType;
</span><span class='line'>    }
</span><span class='line'>    public Type VisualType { get; private set; }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>この属性はデータ（BizViewModelから派生した任意のViewModel）に付与することになります。<br/>
次にビジュアル要素（ビュー）用の基底クラスを用意します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public abstract class BizView : UserControl
</span><span class='line'>{
</span><span class='line'>    protected BizView()
</span><span class='line'>    {
</span><span class='line'>        DataContextChanged += OnBizViewDataContextChanged;
</span><span class='line'>    }
</span><span class='line'>    private void OnBizViewDataContextChanged(object sender, System.Windows.DependencyPropertyChangedEventArgs e)
</span><span class='line'>    {
</span><span class='line'>        BuildBinding();
</span><span class='line'>    }
</span><span class='line'>    protected virtual void BuildBinding()
</span><span class='line'>    {
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上記二つを利用して、BizViewModelに肉付けします。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public abstract class BizViewModel : INotifyPropertyChanged
</span><span class='line'>{
</span><span class='line'>    protected BizViewModel()
</span><span class='line'>    {
</span><span class='line'>        if (VisualElements != null)
</span><span class='line'>        {
</span><span class='line'>            View = Activator.CreateInstance(VisualElements.VisualType) as BizView;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    private VisualElementsAttribute visualElements;
</span><span class='line'>    public VisualElementsAttribute VisualElements
</span><span class='line'>    {
</span><span class='line'>        get
</span><span class='line'>        {
</span><span class='line'>            if (visualElements == null)
</span><span class='line'>            {
</span><span class='line'>                visualElements = this.GetType()
</span><span class='line'>                                     .GetCustomAttributes(typeof(VisualElementsAttribute), false)
</span><span class='line'>                                     .FirstOrDefault() as VisualElementsAttribute;
</span><span class='line'>            }
</span><span class='line'>            return visualElements;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    private BizView view;
</span><span class='line'>    public BizView View
</span><span class='line'>    {
</span><span class='line'>        get { return view; }
</span><span class='line'>        set
</span><span class='line'>        {
</span><span class='line'>            view = value;
</span><span class='line'>            view.DataContext = this;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public event PropertyChangedEventHandler PropertyChanged;
</span><span class='line'>    public void OnPropertyChanged(string propertyName = null)
</span><span class='line'>    {
</span><span class='line'>        if (PropertyChanged != null)
</span><span class='line'>            PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
</span><span class='line'>    }
</span><span class='line'>    protected bool SetProperty&lt;T&gt;(ref T storage, T value,
</span><span class='line'>        [CallerMemberName] string propertyName = null)
</span><span class='line'>    {
</span><span class='line'>        if (object.Equals(storage, value))
</span><span class='line'>            return false;
</span><span class='line'>
</span><span class='line'>        storage = value;
</span><span class='line'>        OnPropertyChanged(propertyName);
</span><span class='line'>        return true;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>先ほどDataTemplateSelectorを派生した動作確認用のサンプルを作成しましたが、正しくビジュアル要素を返すDataTemplateSelectorを作成します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class ViewDataTemplateSelector : DataTemplateSelector
</span><span class='line'>{
</span><span class='line'>    public override DataTemplate SelectTemplate(object item, DependencyObject container)
</span><span class='line'>    {
</span><span class='line'>        var vm = item as BizViewModel;
</span><span class='line'>        if (vm == null || vm.VisualElements == null)
</span><span class='line'>            return base.SelectTemplate(item, container);
</span><span class='line'>
</span><span class='line'>        var template = new DataTemplate() { VisualTree = new FrameworkElementFactory(vm.VisualElements.VisualType) };
</span><span class='line'>        template.Seal();
</span><span class='line'>        return template;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ここまででのLOB開発用の基盤は以下のようになっています。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-15.png" alt="wpf-01-15" /></p>

<p>これを早速使って画面を表示したいと思います。</p>

<h2>LOB開発基盤　-　はじめの一歩</h2>

<p>コンテンツもViewModelも何もない空のMainWindowのみの状態です。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-16.png" alt="wpf-01-16" /></p>

<p>ここにViewを追加します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-17.png" alt="wpf-01-17" /></p>

<p>名前はMainViewで、WPFのユーザーコントロールで追加します。<br/>
VisualStudioにはItemTemplatesフォルダがあって、これを利用すると便利なのですが、それは次回に紹介します。</p>

<p>MainViewクラスのベースクラスをBizViewに変更します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-18.png" alt="wpf-01-18" /></p>

<p>この作業に今は手間がかかりますが、ItemTemplateを紹介するまでの我慢です。</p>

<p>MainView.xamlに先ほど作成した基盤の名前空間をインポート<code>xmlns:uen="clr-namespace:uEN.UI;assembly=uEN"</code>して、メインのタグを<code>&lt;uen:BizView</code>に変更します。<br/>
合わせてMainView.xaml.csのベースクラスも<code>BizView</code>に変更します。</p>

<p>このViewに先ほどと同じようにテキストボックスを配置します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-19.png" alt="wpf-01-19" /></p>

<p>次にMainViewModelを追加します。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-20.png" alt="wpf-01-20" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[VisualElements(typeof(MainView))]
</span><span class='line'>public class MainViewModel : BizViewModel
</span><span class='line'>{
</span><span class='line'>    public MainViewModel()
</span><span class='line'>    {
</span><span class='line'>        MyProperty = "ViewModelでLob開発";
</span><span class='line'>    }
</span><span class='line'>    public string MyProperty { get; set; }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>このViewModelをMainViewのBuildBindingでデータバインディングします。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// &lt;summary&gt;
</span><span class='line'>/// MainView.xaml の相互作用ロジック
</span><span class='line'>/// &lt;/summary&gt;
</span><span class='line'>public partial class MainView : BizView
</span><span class='line'>{
</span><span class='line'>    public MainView()
</span><span class='line'>    {
</span><span class='line'>        InitializeComponent();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    protected override void BuildBinding()
</span><span class='line'>    {
</span><span class='line'>        var viewModel = this.DataContext as MainViewModel;
</span><span class='line'>        var propertyName = viewModel.ToPropertyName(x =&gt; x.MyProperty);
</span><span class='line'>        this.SampleTextBox.SetBinding(TextBox.TextProperty, new Binding(propertyName));
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>今は空のMainWindowとMainView/MainViewModelがある状態です。</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-21.png" alt="wpf-01-21" /></p>

<p>最後にMainWindowにコンテンツとセレクターを設定します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// &lt;summary&gt;
</span><span class='line'>/// MainWindow.xaml の相互作用ロジック
</span><span class='line'>/// &lt;/summary&gt;
</span><span class='line'>public partial class MainWindow : Window
</span><span class='line'>{
</span><span class='line'>    public MainWindow()
</span><span class='line'>    {
</span><span class='line'>        InitializeComponent();
</span><span class='line'>        this.Content = new MainViewModel();
</span><span class='line'>        this.ContentTemplateSelector = new ViewDataTemplateSelector();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>以上で準備が完了です。<br/>
デバック実行すると・・・</p>

<p><img src="http://s-ueno.github.io/images/wpf-01-22.png" alt="wpf-01-22" /></p>

<p>期待した結果が表示されました！</p>

<p>WPFの「おまじないコード」などを基盤に入れていくと、それを利用するLOB開発は楽になると思います。<br/>
たとえば</p>

<ul>
<li>BizViewModelにShowメソッドを用意し、WindowをNewするコードを入れれば・・・</li>
<li>コマンドのバインディングのラッパーを・・・</li>
<li>ロギングが・・・</li>
</ul>


<p>思いつくままをオレオレ実装してもいいですし、<a href="http://www.microsoft.com/ja-jp/dev/2010/solutions/architecture/default.aspx">Application Architecture Guide</a>などを読み解いて、しかるべき処理を準備していくのも一つかもしれません。</p>

<p>次回は今までの作業で手間だったものの自動化を考えてItemTemplatesの紹介と、もう少し踏み込んでボタンを押して動くところまでもっていければと思います。</p>

<p>今回のサンプルは<a href="http://s-ueno.github.io/images/uEN-Vol01.zip">コチラ</a></p>

<hr />
]]></content>
  </entry>
  
</feed>
